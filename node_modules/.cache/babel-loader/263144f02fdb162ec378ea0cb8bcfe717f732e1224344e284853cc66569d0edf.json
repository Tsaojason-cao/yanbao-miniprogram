{"ast":null,"code":"const NAMESPACE = 'ionicons';\nconst BUILD = /* ionicons */{\n  hydratedSelectorName: \"hydrated\",\n  lazyLoad: false,\n  updatable: true\n};\n\n/*\n Stencil Client Platform v4.35.3 | MIT Licensed | https://stenciljs.com\n */\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\n// src/client/client-host-ref.ts\nvar getHostRef = ref => {\n  if (ref.__stencil__getHostRef) {\n    return ref.__stencil__getHostRef();\n  }\n  return void 0;\n};\nvar registerHost = (hostElement, cmpMeta) => {\n  const hostRef = {\n    $flags$: 0,\n    $hostElement$: hostElement,\n    $cmpMeta$: cmpMeta,\n    $instanceValues$: /* @__PURE__ */new Map()\n  };\n  {\n    hostRef.$onReadyPromise$ = new Promise(r => hostRef.$onReadyResolve$ = r);\n    hostElement[\"s-p\"] = [];\n    hostElement[\"s-rc\"] = [];\n  }\n  const ref = hostRef;\n  hostElement.__stencil__getHostRef = () => ref;\n  return ref;\n};\nvar isMemberInElement = (elm, memberName) => memberName in elm;\nvar consoleError = (e, el) => (0, console.error)(e, el);\n\n// src/client/client-style.ts\nvar styles = /* @__PURE__ */new Map();\nvar SLOT_FB_CSS = \"slot-fb{display:contents}slot-fb[hidden]{display:none}\";\nvar XLINK_NS = \"http://www.w3.org/1999/xlink\";\nvar win = typeof window !== \"undefined\" ? window : {};\nvar H = win.HTMLElement || class {};\nvar plt = {\n  $flags$: 0,\n  $resourcesUrl$: \"\",\n  jmp: h2 => h2(),\n  raf: h2 => requestAnimationFrame(h2),\n  ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\n  rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),\n  ce: (eventName, opts) => new CustomEvent(eventName, opts)\n};\nvar promiseResolve = v => Promise.resolve(v);\nvar supportsConstructableStylesheets = /* @__PURE__ */(() => {\n  try {\n    new CSSStyleSheet();\n    return typeof new CSSStyleSheet().replaceSync === \"function\";\n  } catch (e) {}\n  return false;\n})();\nvar queuePending = false;\nvar queueDomReads = [];\nvar queueDomWrites = [];\nvar queueTask = (queue, write) => cb => {\n  queue.push(cb);\n  if (!queuePending) {\n    queuePending = true;\n    if (write && plt.$flags$ & 4 /* queueSync */) {\n      nextTick(flush);\n    } else {\n      plt.raf(flush);\n    }\n  }\n};\nvar consume = queue => {\n  for (let i2 = 0; i2 < queue.length; i2++) {\n    try {\n      queue[i2](performance.now());\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n  queue.length = 0;\n};\nvar flush = () => {\n  consume(queueDomReads);\n  {\n    consume(queueDomWrites);\n    if (queuePending = queueDomReads.length > 0) {\n      plt.raf(flush);\n    }\n  }\n};\nvar nextTick = cb => promiseResolve().then(cb);\nvar writeTask = /* @__PURE__ */queueTask(queueDomWrites, true);\n\n// src/runtime/asset-path.ts\nvar getAssetPath = path => {\n  const assetUrl = new URL(path, plt.$resourcesUrl$);\n  return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;\n};\nvar setAssetPath = path => plt.$resourcesUrl$ = path;\nvar isComplexType = o => {\n  o = typeof o;\n  return o === \"object\" || o === \"function\";\n};\n\n// src/utils/query-nonce-meta-tag-content.ts\nfunction queryNonceMetaTagContent(doc) {\n  var _a, _b, _c;\n  return (_c = (_b = (_a = doc.head) == null ? void 0 : _a.querySelector('meta[name=\"csp-nonce\"]')) == null ? void 0 : _b.getAttribute(\"content\")) != null ? _c : void 0;\n}\n\n// src/utils/regular-expression.ts\nvar escapeRegExpSpecialCharacters = text => {\n  return text.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n};\n\n// src/utils/result.ts\nvar result_exports = {};\n__export(result_exports, {\n  err: () => err,\n  map: () => map,\n  ok: () => ok,\n  unwrap: () => unwrap,\n  unwrapErr: () => unwrapErr\n});\nvar ok = value => ({\n  isOk: true,\n  isErr: false,\n  value\n});\nvar err = value => ({\n  isOk: false,\n  isErr: true,\n  value\n});\nfunction map(result, fn) {\n  if (result.isOk) {\n    const val = fn(result.value);\n    if (val instanceof Promise) {\n      return val.then(newVal => ok(newVal));\n    } else {\n      return ok(val);\n    }\n  }\n  if (result.isErr) {\n    const value = result.value;\n    return err(value);\n  }\n  throw \"should never get here\";\n}\nvar unwrap = result => {\n  if (result.isOk) {\n    return result.value;\n  } else {\n    throw result.value;\n  }\n};\nvar unwrapErr = result => {\n  if (result.isErr) {\n    return result.value;\n  } else {\n    throw result.value;\n  }\n};\n\n// src/utils/style.ts\nfunction createStyleSheetIfNeededAndSupported(styles2) {\n  return void 0;\n}\n\n// src/utils/shadow-root.ts\nvar globalStyleSheet;\nfunction createShadowRoot(cmpMeta) {\n  var _a;\n  const shadowRoot = this.attachShadow({\n    mode: \"open\"\n  });\n  if (globalStyleSheet === void 0) globalStyleSheet = (_a = createStyleSheetIfNeededAndSupported()) != null ? _a : null;\n  if (globalStyleSheet) shadowRoot.adoptedStyleSheets.push(globalStyleSheet);\n}\nvar createTime = function (fnName) {\n  let tagName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  {\n    return () => {\n      return;\n    };\n  }\n};\nvar rootAppliedStyles = /* @__PURE__ */new WeakMap();\nvar registerStyle = (scopeId2, cssText, allowCS) => {\n  let style = styles.get(scopeId2);\n  if (supportsConstructableStylesheets && allowCS) {\n    style = style || new CSSStyleSheet();\n    if (typeof style === \"string\") {\n      style = cssText;\n    } else {\n      style.replaceSync(cssText);\n    }\n  } else {\n    style = cssText;\n  }\n  styles.set(scopeId2, style);\n};\nvar addStyle = (styleContainerNode, cmpMeta, mode) => {\n  var _a;\n  const scopeId2 = getScopeId(cmpMeta);\n  const style = styles.get(scopeId2);\n  if (!win.document) {\n    return scopeId2;\n  }\n  styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : win.document;\n  if (style) {\n    if (typeof style === \"string\") {\n      styleContainerNode = styleContainerNode.head || styleContainerNode;\n      let appliedStyles = rootAppliedStyles.get(styleContainerNode);\n      let styleElm;\n      if (!appliedStyles) {\n        rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */new Set());\n      }\n      if (!appliedStyles.has(scopeId2)) {\n        {\n          styleElm = win.document.createElement(\"style\");\n          styleElm.innerHTML = style;\n          const nonce = (_a = plt.$nonce$) != null ? _a : queryNonceMetaTagContent(win.document);\n          if (nonce != null) {\n            styleElm.setAttribute(\"nonce\", nonce);\n          }\n          if (!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */)) {\n            if (styleContainerNode.nodeName === \"HEAD\") {\n              const preconnectLinks = styleContainerNode.querySelectorAll(\"link[rel=preconnect]\");\n              const referenceNode2 = preconnectLinks.length > 0 ? preconnectLinks[preconnectLinks.length - 1].nextSibling : styleContainerNode.querySelector(\"style\");\n              styleContainerNode.insertBefore(styleElm, (referenceNode2 == null ? void 0 : referenceNode2.parentNode) === styleContainerNode ? referenceNode2 : null);\n            } else if (\"host\" in styleContainerNode) {\n              if (supportsConstructableStylesheets) {\n                const stylesheet = new CSSStyleSheet();\n                stylesheet.replaceSync(style);\n                styleContainerNode.adoptedStyleSheets.unshift(stylesheet);\n              } else {\n                const existingStyleContainer = styleContainerNode.querySelector(\"style\");\n                if (existingStyleContainer) {\n                  existingStyleContainer.innerHTML = style + existingStyleContainer.innerHTML;\n                } else {\n                  styleContainerNode.prepend(styleElm);\n                }\n              }\n            } else {\n              styleContainerNode.append(styleElm);\n            }\n          }\n          if (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n            styleContainerNode.insertBefore(styleElm, null);\n          }\n        }\n        if (cmpMeta.$flags$ & 4 /* hasSlotRelocation */) {\n          styleElm.innerHTML += SLOT_FB_CSS;\n        }\n        if (appliedStyles) {\n          appliedStyles.add(scopeId2);\n        }\n      }\n    } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {\n      styleContainerNode.adoptedStyleSheets.push(style);\n    }\n  }\n  return scopeId2;\n};\nvar attachStyles = hostRef => {\n  const cmpMeta = hostRef.$cmpMeta$;\n  const elm = hostRef.$hostElement$;\n  const flags = cmpMeta.$flags$;\n  const endAttachStyles = createTime(\"attachStyles\", cmpMeta.$tagName$);\n  const scopeId2 = addStyle(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta);\n  if (flags & 10 /* needsScopedEncapsulation */) {\n    elm[\"s-sc\"] = scopeId2;\n    elm.classList.add(scopeId2 + \"-h\");\n  }\n  endAttachStyles();\n};\nvar getScopeId = (cmp, mode) => \"sc-\" + cmp.$tagName$;\nvar h = function (nodeName, vnodeData) {\n  let child = null;\n  let key = null;\n  let simple = false;\n  let lastSimple = false;\n  const vNodeChildren = [];\n  const walk = c => {\n    for (let i2 = 0; i2 < c.length; i2++) {\n      child = c[i2];\n      if (Array.isArray(child)) {\n        walk(child);\n      } else if (child != null && typeof child !== \"boolean\") {\n        if (simple = typeof nodeName !== \"function\" && !isComplexType(child)) {\n          child = String(child);\n        }\n        if (simple && lastSimple) {\n          vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n        } else {\n          vNodeChildren.push(simple ? newVNode(null, child) : child);\n        }\n        lastSimple = simple;\n      }\n    }\n  };\n  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    children[_key - 2] = arguments[_key];\n  }\n  walk(children);\n  if (vnodeData) {\n    if (vnodeData.key) {\n      key = vnodeData.key;\n    }\n    {\n      const classData = vnodeData.className || vnodeData.class;\n      if (classData) {\n        vnodeData.class = typeof classData !== \"object\" ? classData : Object.keys(classData).filter(k => classData[k]).join(\" \");\n      }\n    }\n  }\n  const vnode = newVNode(nodeName, null);\n  vnode.$attrs$ = vnodeData;\n  if (vNodeChildren.length > 0) {\n    vnode.$children$ = vNodeChildren;\n  }\n  {\n    vnode.$key$ = key;\n  }\n  return vnode;\n};\nvar newVNode = (tag, text) => {\n  const vnode = {\n    $flags$: 0,\n    $tag$: tag,\n    $text$: text,\n    $elm$: null,\n    $children$: null\n  };\n  {\n    vnode.$attrs$ = null;\n  }\n  {\n    vnode.$key$ = null;\n  }\n  return vnode;\n};\nvar Host = {};\nvar isHost = node => node && node.$tag$ === Host;\nvar createSupportsRuleRe = selector => {\n  const safeSelector2 = escapeRegExpSpecialCharacters(selector);\n  return new RegExp(// First capture group: match any context before the selector that's not inside @supports selector()\n  // Using negative lookahead to avoid matching inside @supports selector(...) condition\n  \"(^|[^@]|@(?!supports\\\\s+selector\\\\s*\\\\([^{]*?\".concat(safeSelector2, \"))(\").concat(safeSelector2, \"\\\\b)\"), \"g\");\n};\ncreateSupportsRuleRe(\"::slotted\");\ncreateSupportsRuleRe(\":host\");\ncreateSupportsRuleRe(\":host-context\");\nvar parsePropertyValue = (propValue, propType, isFormAssociated) => {\n  if (propValue != null && !isComplexType(propValue)) {\n    if (propType & 4 /* Boolean */) {\n      {\n        return propValue === \"false\" ? false : propValue === \"\" || !!propValue;\n      }\n    }\n    if (propType & 1 /* String */) {\n      return String(propValue);\n    }\n    return propValue;\n  }\n  return propValue;\n};\nvar emitEvent = (elm, name, opts) => {\n  const ev = plt.ce(name, opts);\n  elm.dispatchEvent(ev);\n  return ev;\n};\nvar setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags, initialRender) => {\n  if (oldValue === newValue) {\n    return;\n  }\n  let isProp = isMemberInElement(elm, memberName);\n  let ln = memberName.toLowerCase();\n  if (memberName === \"class\") {\n    const classList = elm.classList;\n    const oldClasses = parseClassList(oldValue);\n    let newClasses = parseClassList(newValue);\n    {\n      classList.remove(...oldClasses.filter(c => c && !newClasses.includes(c)));\n      classList.add(...newClasses.filter(c => c && !oldClasses.includes(c)));\n    }\n  } else if (memberName === \"style\") {\n    {\n      for (const prop in oldValue) {\n        if (!newValue || newValue[prop] == null) {\n          if (prop.includes(\"-\")) {\n            elm.style.removeProperty(prop);\n          } else {\n            elm.style[prop] = \"\";\n          }\n        }\n      }\n    }\n    for (const prop in newValue) {\n      if (!oldValue || newValue[prop] !== oldValue[prop]) {\n        if (prop.includes(\"-\")) {\n          elm.style.setProperty(prop, newValue[prop]);\n        } else {\n          elm.style[prop] = newValue[prop];\n        }\n      }\n    }\n  } else if (memberName === \"key\") ;else if (memberName === \"ref\") {\n    if (newValue) {\n      newValue(elm);\n    }\n  } else if (!elm.__lookupSetter__(memberName) && memberName[0] === \"o\" && memberName[1] === \"n\") {\n    if (memberName[2] === \"-\") {\n      memberName = memberName.slice(3);\n    } else if (isMemberInElement(win, ln)) {\n      memberName = ln.slice(2);\n    } else {\n      memberName = ln[2] + memberName.slice(3);\n    }\n    if (oldValue || newValue) {\n      const capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX);\n      memberName = memberName.replace(CAPTURE_EVENT_REGEX, \"\");\n      if (oldValue) {\n        plt.rel(elm, memberName, oldValue, capture);\n      }\n      if (newValue) {\n        plt.ael(elm, memberName, newValue, capture);\n      }\n    }\n  } else {\n    const isComplex = isComplexType(newValue);\n    if ((isProp || isComplex && newValue !== null) && true) {\n      try {\n        if (!elm.tagName.includes(\"-\")) {\n          const n = newValue == null ? \"\" : newValue;\n          if (memberName === \"list\") {\n            isProp = false;\n          } else if (oldValue == null || elm[memberName] != n) {\n            if (typeof elm.__lookupSetter__(memberName) === \"function\") {\n              elm[memberName] = n;\n            } else {\n              elm.setAttribute(memberName, n);\n            }\n          }\n        } else if (elm[memberName] !== newValue) {\n          elm[memberName] = newValue;\n        }\n      } catch (e) {}\n    }\n    let xlink = false;\n    {\n      if (ln !== (ln = ln.replace(/^xlink\\:?/, \"\"))) {\n        memberName = ln;\n        xlink = true;\n      }\n    }\n    if (newValue == null || newValue === false) {\n      if (newValue !== false || elm.getAttribute(memberName) === \"\") {\n        if (xlink) {\n          elm.removeAttributeNS(XLINK_NS, memberName);\n        } else {\n          elm.removeAttribute(memberName);\n        }\n      }\n    } else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex && elm.nodeType === 1 /* ElementNode */) {\n      newValue = newValue === true ? \"\" : newValue;\n      if (xlink) {\n        elm.setAttributeNS(XLINK_NS, memberName, newValue);\n      } else {\n        elm.setAttribute(memberName, newValue);\n      }\n    }\n  }\n};\nvar parseClassListRegex = /\\s/;\nvar parseClassList = value => {\n  if (typeof value === \"object\" && value && \"baseVal\" in value) {\n    value = value.baseVal;\n  }\n  if (!value || typeof value !== \"string\") {\n    return [];\n  }\n  return value.split(parseClassListRegex);\n};\nvar CAPTURE_EVENT_SUFFIX = \"Capture\";\nvar CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + \"$\");\n\n// src/runtime/vdom/update-element.ts\nvar updateElement = (oldVnode, newVnode, isSvgMode2, isInitialRender) => {\n  const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;\n  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || {};\n  const newVnodeAttrs = newVnode.$attrs$ || {};\n  {\n    for (const memberName of sortedAttrNames(Object.keys(oldVnodeAttrs))) {\n      if (!(memberName in newVnodeAttrs)) {\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);\n      }\n    }\n  }\n  for (const memberName of sortedAttrNames(Object.keys(newVnodeAttrs))) {\n    setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);\n  }\n};\nfunction sortedAttrNames(attrNames) {\n  return attrNames.includes(\"ref\") ?\n  // we need to sort these to ensure that `'ref'` is the last attr\n  [...attrNames.filter(attr => attr !== \"ref\"), \"ref\"] :\n  // no need to sort, return the original array\n  attrNames;\n}\nvar hostTagName;\nvar isSvgMode = false;\nvar createElm = (oldParentVNode, newParentVNode, childIndex) => {\n  const newVNode2 = newParentVNode.$children$[childIndex];\n  let i2 = 0;\n  let elm;\n  let childNode;\n  if (newVNode2.$text$ !== null) {\n    elm = newVNode2.$elm$ = win.document.createTextNode(newVNode2.$text$);\n  } else {\n    if (!win.document) {\n      throw new Error(\"You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component.\");\n    }\n    elm = newVNode2.$elm$ = win.document.createElement(newVNode2.$tag$);\n    {\n      updateElement(null, newVNode2, isSvgMode);\n    }\n    if (newVNode2.$children$) {\n      for (i2 = 0; i2 < newVNode2.$children$.length; ++i2) {\n        childNode = createElm(oldParentVNode, newVNode2, i2);\n        if (childNode) {\n          elm.appendChild(childNode);\n        }\n      }\n    }\n  }\n  elm[\"s-hn\"] = hostTagName;\n  return elm;\n};\nvar addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\n  let containerElm = parentElm;\n  let childNode;\n  if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n    containerElm = containerElm.shadowRoot;\n  }\n  for (; startIdx <= endIdx; ++startIdx) {\n    if (vnodes[startIdx]) {\n      childNode = createElm(null, parentVNode, startIdx);\n      if (childNode) {\n        vnodes[startIdx].$elm$ = childNode;\n        insertBefore(containerElm, childNode, before);\n      }\n    }\n  }\n};\nvar removeVnodes = (vnodes, startIdx, endIdx) => {\n  for (let index = startIdx; index <= endIdx; ++index) {\n    const vnode = vnodes[index];\n    if (vnode) {\n      const elm = vnode.$elm$;\n      nullifyVNodeRefs(vnode);\n      if (elm) {\n        elm.remove();\n      }\n    }\n  }\n};\nvar updateChildren = function (parentElm, oldCh, newVNode2, newCh) {\n  let isInitialRender = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let oldStartIdx = 0;\n  let newStartIdx = 0;\n  let idxInOld = 0;\n  let i2 = 0;\n  let oldEndIdx = oldCh.length - 1;\n  let oldStartVnode = oldCh[0];\n  let oldEndVnode = oldCh[oldEndIdx];\n  let newEndIdx = newCh.length - 1;\n  let newStartVnode = newCh[0];\n  let newEndVnode = newCh[newEndIdx];\n  let node;\n  let elmToMove;\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (oldStartVnode == null) {\n      oldStartVnode = oldCh[++oldStartIdx];\n    } else if (oldEndVnode == null) {\n      oldEndVnode = oldCh[--oldEndIdx];\n    } else if (newStartVnode == null) {\n      newStartVnode = newCh[++newStartIdx];\n    } else if (newEndVnode == null) {\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {\n      patch(oldStartVnode, newStartVnode, isInitialRender);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {\n      patch(oldEndVnode, newEndVnode, isInitialRender);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {\n      patch(oldStartVnode, newEndVnode, isInitialRender);\n      insertBefore(parentElm, oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {\n      patch(oldEndVnode, newStartVnode, isInitialRender);\n      insertBefore(parentElm, oldEndVnode.$elm$, oldStartVnode.$elm$);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else {\n      idxInOld = -1;\n      {\n        for (i2 = oldStartIdx; i2 <= oldEndIdx; ++i2) {\n          if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {\n            idxInOld = i2;\n            break;\n          }\n        }\n      }\n      if (idxInOld >= 0) {\n        elmToMove = oldCh[idxInOld];\n        if (elmToMove.$tag$ !== newStartVnode.$tag$) {\n          node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld);\n        } else {\n          patch(elmToMove, newStartVnode, isInitialRender);\n          oldCh[idxInOld] = void 0;\n          node = elmToMove.$elm$;\n        }\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx);\n        newStartVnode = newCh[++newStartIdx];\n      }\n      if (node) {\n        {\n          insertBefore(oldStartVnode.$elm$.parentNode, node, oldStartVnode.$elm$);\n        }\n      }\n    }\n  }\n  if (oldStartIdx > oldEndIdx) {\n    addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode2, newCh, newStartIdx, newEndIdx);\n  } else if (newStartIdx > newEndIdx) {\n    removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n  }\n};\nvar isSameVnode = function (leftVNode, rightVNode) {\n  let isInitialRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (leftVNode.$tag$ === rightVNode.$tag$) {\n    if (!isInitialRender) {\n      return leftVNode.$key$ === rightVNode.$key$;\n    }\n    if (isInitialRender && !leftVNode.$key$ && rightVNode.$key$) {\n      leftVNode.$key$ = rightVNode.$key$;\n    }\n    return true;\n  }\n  return false;\n};\nvar patch = function (oldVNode, newVNode2) {\n  let isInitialRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const elm = newVNode2.$elm$ = oldVNode.$elm$;\n  const oldChildren = oldVNode.$children$;\n  const newChildren = newVNode2.$children$;\n  const text = newVNode2.$text$;\n  if (text === null) {\n    {\n      updateElement(oldVNode, newVNode2, isSvgMode);\n    }\n    if (oldChildren !== null && newChildren !== null) {\n      updateChildren(elm, oldChildren, newVNode2, newChildren, isInitialRender);\n    } else if (newChildren !== null) {\n      if (oldVNode.$text$ !== null) {\n        elm.textContent = \"\";\n      }\n      addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);\n    } else if (\n    // don't do this on initial render as it can cause non-hydrated content to be removed\n    !isInitialRender && BUILD.updatable && oldChildren !== null) {\n      removeVnodes(oldChildren, 0, oldChildren.length - 1);\n    } else ;\n  } else if (oldVNode.$text$ !== text) {\n    elm.data = text;\n  }\n};\nvar nullifyVNodeRefs = vNode => {\n  {\n    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n    vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);\n  }\n};\nvar insertBefore = (parent, newNode, reference) => {\n  {\n    return parent == null ? void 0 : parent.insertBefore(newNode, reference);\n  }\n};\nvar renderVdom = function (hostRef, renderFnResults) {\n  let isInitialLoad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const hostElm = hostRef.$hostElement$;\n  const cmpMeta = hostRef.$cmpMeta$;\n  const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n  const isHostElement = isHost(renderFnResults);\n  const rootVnode = isHostElement ? renderFnResults : h(null, null, renderFnResults);\n  hostTagName = hostElm.tagName;\n  if (cmpMeta.$attrsToReflect$) {\n    rootVnode.$attrs$ = rootVnode.$attrs$ || {};\n    cmpMeta.$attrsToReflect$.map(_ref => {\n      let [propName, attribute] = _ref;\n      return rootVnode.$attrs$[attribute] = hostElm[propName];\n    });\n  }\n  if (isInitialLoad && rootVnode.$attrs$) {\n    for (const key of Object.keys(rootVnode.$attrs$)) {\n      if (hostElm.hasAttribute(key) && ![\"key\", \"ref\", \"style\", \"class\"].includes(key)) {\n        rootVnode.$attrs$[key] = hostElm[key];\n      }\n    }\n  }\n  rootVnode.$tag$ = null;\n  rootVnode.$flags$ |= 4 /* isHost */;\n  hostRef.$vnode$ = rootVnode;\n  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;\n  patch(oldVNode, rootVnode, isInitialLoad);\n};\n\n// src/runtime/update-component.ts\nvar attachToAncestor = (hostRef, ancestorComponent) => {\n  if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent[\"s-p\"]) {\n    const index = ancestorComponent[\"s-p\"].push(new Promise(r => hostRef.$onRenderResolve$ = () => {\n      ancestorComponent[\"s-p\"].splice(index - 1, 1);\n      r();\n    }));\n  }\n};\nvar scheduleUpdate = (hostRef, isInitialLoad) => {\n  {\n    hostRef.$flags$ |= 16 /* isQueuedForUpdate */;\n  }\n  if (hostRef.$flags$ & 4 /* isWaitingForChildren */) {\n    hostRef.$flags$ |= 512 /* needsRerender */;\n    return;\n  }\n  attachToAncestor(hostRef, hostRef.$ancestorComponent$);\n  const dispatch = () => dispatchHooks(hostRef, isInitialLoad);\n  return writeTask(dispatch);\n};\nvar dispatchHooks = (hostRef, isInitialLoad) => {\n  const elm = hostRef.$hostElement$;\n  const endSchedule = createTime(\"scheduleUpdate\", hostRef.$cmpMeta$.$tagName$);\n  const instance = elm;\n  if (!instance) {\n    throw new Error(\"Can't render component <\".concat(elm.tagName.toLowerCase(), \" /> with invalid Stencil runtime! Make sure this imported component is compiled with a `externalRuntime: true` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime\"));\n  }\n  let maybePromise;\n  if (isInitialLoad) {\n    maybePromise = safeCall(instance, \"componentWillLoad\", void 0, elm);\n  } else {\n    maybePromise = safeCall(instance, \"componentWillUpdate\", void 0, elm);\n  }\n  maybePromise = enqueue(maybePromise, () => safeCall(instance, \"componentWillRender\", void 0, elm));\n  endSchedule();\n  return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));\n};\nvar enqueue = (maybePromise, fn) => isPromisey(maybePromise) ? maybePromise.then(fn).catch(err2 => {\n  console.error(err2);\n  fn();\n}) : fn();\nvar isPromisey = maybePromise => maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === \"function\";\nvar updateComponent = async (hostRef, instance, isInitialLoad) => {\n  var _a;\n  const elm = hostRef.$hostElement$;\n  const endUpdate = createTime(\"update\", hostRef.$cmpMeta$.$tagName$);\n  const rc = elm[\"s-rc\"];\n  if (isInitialLoad) {\n    attachStyles(hostRef);\n  }\n  const endRender = createTime(\"render\", hostRef.$cmpMeta$.$tagName$);\n  {\n    callRender(hostRef, instance, elm, isInitialLoad);\n  }\n  if (rc) {\n    rc.map(cb => cb());\n    elm[\"s-rc\"] = void 0;\n  }\n  endRender();\n  endUpdate();\n  {\n    const childrenPromises = (_a = elm[\"s-p\"]) != null ? _a : [];\n    const postUpdate = () => postUpdateComponent(hostRef);\n    if (childrenPromises.length === 0) {\n      postUpdate();\n    } else {\n      Promise.all(childrenPromises).then(postUpdate);\n      hostRef.$flags$ |= 4 /* isWaitingForChildren */;\n      childrenPromises.length = 0;\n    }\n  }\n};\nvar callRender = (hostRef, instance, elm, isInitialLoad) => {\n  try {\n    instance = instance.render();\n    {\n      hostRef.$flags$ &= -17 /* isQueuedForUpdate */;\n    }\n    {\n      hostRef.$flags$ |= 2 /* hasRendered */;\n    }\n    {\n      {\n        {\n          renderVdom(hostRef, instance, isInitialLoad);\n        }\n      }\n    }\n  } catch (e) {\n    consoleError(e, hostRef.$hostElement$);\n  }\n  return null;\n};\nvar postUpdateComponent = hostRef => {\n  const tagName = hostRef.$cmpMeta$.$tagName$;\n  const elm = hostRef.$hostElement$;\n  const endPostUpdate = createTime(\"postUpdate\", tagName);\n  const instance = elm;\n  const ancestorComponent = hostRef.$ancestorComponent$;\n  safeCall(instance, \"componentDidRender\", void 0, elm);\n  if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {\n    hostRef.$flags$ |= 64 /* hasLoadedComponent */;\n    {\n      addHydratedFlag(elm);\n    }\n    safeCall(instance, \"componentDidLoad\", void 0, elm);\n    endPostUpdate();\n    {\n      hostRef.$onReadyResolve$(elm);\n      if (!ancestorComponent) {\n        appDidLoad();\n      }\n    }\n  } else {\n    safeCall(instance, \"componentDidUpdate\", void 0, elm);\n    endPostUpdate();\n  }\n  {\n    if (hostRef.$onRenderResolve$) {\n      hostRef.$onRenderResolve$();\n      hostRef.$onRenderResolve$ = void 0;\n    }\n    if (hostRef.$flags$ & 512 /* needsRerender */) {\n      nextTick(() => scheduleUpdate(hostRef, false));\n    }\n    hostRef.$flags$ &= -517;\n  }\n};\nvar appDidLoad = who => {\n  nextTick(() => emitEvent(win, \"appload\", {\n    detail: {\n      namespace: NAMESPACE\n    }\n  }));\n};\nvar safeCall = (instance, method, arg, elm) => {\n  if (instance && instance[method]) {\n    try {\n      return instance[method](arg);\n    } catch (e) {\n      consoleError(e, elm);\n    }\n  }\n  return void 0;\n};\nvar addHydratedFlag = elm => {\n  var _a;\n  return elm.classList.add((_a = BUILD.hydratedSelectorName) != null ? _a : \"hydrated\");\n};\n\n// src/runtime/set-value.ts\nvar getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\nvar setValue = (ref, propName, newVal, cmpMeta) => {\n  const hostRef = getHostRef(ref);\n  const elm = ref;\n  const oldVal = hostRef.$instanceValues$.get(propName);\n  const flags = hostRef.$flags$;\n  const instance = elm;\n  newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);\n  const didValueChange = newVal !== oldVal && !areBothNaN;\n  if (didValueChange) {\n    hostRef.$instanceValues$.set(propName, newVal);\n    {\n      if (cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {\n        const watchMethods = cmpMeta.$watchers$[propName];\n        if (watchMethods) {\n          watchMethods.map(watchMethodName => {\n            try {\n              instance[watchMethodName](newVal, oldVal, propName);\n            } catch (e) {\n              consoleError(e, elm);\n            }\n          });\n        }\n      }\n      if ((flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n        if (instance.componentShouldUpdate) {\n          if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {\n            return;\n          }\n        }\n        scheduleUpdate(hostRef, false);\n      }\n    }\n  }\n};\n\n// src/runtime/proxy-component.ts\nvar proxyComponent = (Cstr, cmpMeta, flags) => {\n  var _a, _b;\n  const prototype = Cstr.prototype;\n  if (cmpMeta.$members$ || cmpMeta.$watchers$ || Cstr.watchers) {\n    if (Cstr.watchers && !cmpMeta.$watchers$) {\n      cmpMeta.$watchers$ = Cstr.watchers;\n    }\n    const members = Object.entries((_a = cmpMeta.$members$) != null ? _a : {});\n    members.map(_ref2 => {\n      let [memberName, [memberFlags]] = _ref2;\n      if (memberFlags & 31 /* Prop */ || memberFlags & 32 /* State */) {\n        const {\n          get: origGetter,\n          set: origSetter\n        } = Object.getOwnPropertyDescriptor(prototype, memberName) || {};\n        if (origGetter) cmpMeta.$members$[memberName][0] |= 2048 /* Getter */;\n        if (origSetter) cmpMeta.$members$[memberName][0] |= 4096 /* Setter */;\n        {\n          Object.defineProperty(prototype, memberName, {\n            get() {\n              {\n                return origGetter ? origGetter.apply(this) : getValue(this, memberName);\n              }\n            },\n            configurable: true,\n            enumerable: true\n          });\n        }\n        Object.defineProperty(prototype, memberName, {\n          set(newValue) {\n            const ref = getHostRef(this);\n            if (origSetter) {\n              const currentValue = memberFlags & 32 /* State */ ? this[memberName] : ref.$hostElement$[memberName];\n              if (typeof currentValue === \"undefined\" && ref.$instanceValues$.get(memberName)) {\n                newValue = ref.$instanceValues$.get(memberName);\n              } else if (!ref.$instanceValues$.get(memberName) && currentValue) {\n                ref.$instanceValues$.set(memberName, currentValue);\n              }\n              origSetter.apply(this, [parsePropertyValue(newValue, memberFlags)]);\n              newValue = memberFlags & 32 /* State */ ? this[memberName] : ref.$hostElement$[memberName];\n              setValue(this, memberName, newValue, cmpMeta);\n              return;\n            }\n            {\n              setValue(this, memberName, newValue, cmpMeta);\n              return;\n            }\n          }\n        });\n      }\n    });\n    {\n      const attrNameToPropName = /* @__PURE__ */new Map();\n      prototype.attributeChangedCallback = function (attrName, oldValue, newValue) {\n        plt.jmp(() => {\n          var _a2;\n          const propName = attrNameToPropName.get(attrName);\n          if (this.hasOwnProperty(propName) && BUILD.lazyLoad) ;else if (prototype.hasOwnProperty(propName) && typeof this[propName] === \"number\" &&\n          // cast type to number to avoid TS compiler issues\n          this[propName] == newValue) {\n            return;\n          } else if (propName == null) {\n            const hostRef = getHostRef(this);\n            const flags2 = hostRef == null ? void 0 : hostRef.$flags$;\n            if (flags2 && !(flags2 & 8 /* isConstructingInstance */) && flags2 & 128 /* isWatchReady */ && newValue !== oldValue) {\n              const elm = this;\n              const instance = elm;\n              const entry = (_a2 = cmpMeta.$watchers$) == null ? void 0 : _a2[attrName];\n              entry == null ? void 0 : entry.forEach(callbackName => {\n                if (instance[callbackName] != null) {\n                  instance[callbackName].call(instance, newValue, oldValue, attrName);\n                }\n              });\n            }\n            return;\n          }\n          const propDesc = Object.getOwnPropertyDescriptor(prototype, propName);\n          newValue = newValue === null && typeof this[propName] === \"boolean\" ? false : newValue;\n          if (newValue !== this[propName] && (!propDesc.get || !!propDesc.set)) {\n            this[propName] = newValue;\n          }\n        });\n      };\n      Cstr.observedAttributes = Array.from(/* @__PURE__ */new Set([...Object.keys((_b = cmpMeta.$watchers$) != null ? _b : {}), ...members.filter(_ref3 => {\n        let [_, m] = _ref3;\n        return m[0] & 15;\n      } /* HasAttribute */).map(_ref4 => {\n        let [propName, m] = _ref4;\n        var _a2;\n        const attrName = m[1] || propName;\n        attrNameToPropName.set(attrName, propName);\n        if (m[0] & 512 /* ReflectAttr */) {\n          (_a2 = cmpMeta.$attrsToReflect$) == null ? void 0 : _a2.push([propName, attrName]);\n        }\n        return attrName;\n      })]));\n    }\n  }\n  return Cstr;\n};\n\n// src/runtime/initialize-component.ts\nvar initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId) => {\n  let Cstr;\n  if ((hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {\n    hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n    {\n      Cstr = elm.constructor;\n      const cmpTag = elm.localName;\n      customElements.whenDefined(cmpTag).then(() => hostRef.$flags$ |= 128 /* isWatchReady */);\n    }\n    if (Cstr && Cstr.style) {\n      let style;\n      if (typeof Cstr.style === \"string\") {\n        style = Cstr.style;\n      }\n      const scopeId2 = getScopeId(cmpMeta);\n      if (!styles.has(scopeId2)) {\n        const endRegisterStyles = createTime(\"registerStyles\", cmpMeta.$tagName$);\n        registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));\n        endRegisterStyles();\n      }\n    }\n  }\n  const ancestorComponent = hostRef.$ancestorComponent$;\n  const schedule = () => scheduleUpdate(hostRef, true);\n  if (ancestorComponent && ancestorComponent[\"s-rc\"]) {\n    ancestorComponent[\"s-rc\"].push(schedule);\n  } else {\n    schedule();\n  }\n};\nvar fireConnectedCallback = (instance, elm) => {};\n\n// src/runtime/connected-callback.ts\nvar connectedCallback = elm => {\n  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n    const hostRef = getHostRef(elm);\n    const cmpMeta = hostRef.$cmpMeta$;\n    const endConnected = createTime(\"connectedCallback\", cmpMeta.$tagName$);\n    if (!(hostRef.$flags$ & 1 /* hasConnected */)) {\n      hostRef.$flags$ |= 1 /* hasConnected */;\n      {\n        let ancestorComponent = elm;\n        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {\n          if (ancestorComponent[\"s-p\"]) {\n            attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);\n            break;\n          }\n        }\n      }\n      if (cmpMeta.$members$) {\n        Object.entries(cmpMeta.$members$).map(_ref5 => {\n          let [memberName, [memberFlags]] = _ref5;\n          if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {\n            const value = elm[memberName];\n            delete elm[memberName];\n            elm[memberName] = value;\n          }\n        });\n      }\n      if (BUILD.initializeNextTick) {\n        nextTick(() => initializeComponent(elm, hostRef, cmpMeta));\n      } else {\n        initializeComponent(elm, hostRef, cmpMeta);\n      }\n    } else {\n      if (hostRef == null ? void 0 : hostRef.$lazyInstance$) ;else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {\n        hostRef.$onReadyPromise$.then(() => fireConnectedCallback());\n      }\n    }\n    endConnected();\n  }\n};\nvar disconnectedCallback = async elm => {\n  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n    getHostRef(elm);\n  }\n  if (rootAppliedStyles.has(elm)) {\n    rootAppliedStyles.delete(elm);\n  }\n  if (elm.shadowRoot && rootAppliedStyles.has(elm.shadowRoot)) {\n    rootAppliedStyles.delete(elm.shadowRoot);\n  }\n};\nvar proxyCustomElement = (Cstr, compactMeta) => {\n  const cmpMeta = {\n    $flags$: compactMeta[0],\n    $tagName$: compactMeta[1]\n  };\n  {\n    cmpMeta.$members$ = compactMeta[2];\n  }\n  {\n    cmpMeta.$watchers$ = Cstr.$watchers$;\n  }\n  {\n    cmpMeta.$attrsToReflect$ = [];\n  }\n  const originalConnectedCallback = Cstr.prototype.connectedCallback;\n  const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;\n  Object.assign(Cstr.prototype, {\n    __hasHostListenerAttached: false,\n    __registerHost() {\n      registerHost(this, cmpMeta);\n    },\n    connectedCallback() {\n      if (!this.__hasHostListenerAttached) {\n        getHostRef(this);\n        this.__hasHostListenerAttached = true;\n      }\n      connectedCallback(this);\n      if (originalConnectedCallback) {\n        originalConnectedCallback.call(this);\n      }\n    },\n    disconnectedCallback() {\n      disconnectedCallback(this);\n      if (originalDisconnectedCallback) {\n        originalDisconnectedCallback.call(this);\n      }\n    },\n    __attachShadow() {\n      {\n        if (!this.shadowRoot) {\n          createShadowRoot.call(this, cmpMeta);\n        } else {\n          if (this.shadowRoot.mode !== \"open\") {\n            throw new Error(\"Unable to re-use existing shadow root for \".concat(cmpMeta.$tagName$, \"! Mode is set to \").concat(this.shadowRoot.mode, \" but Stencil only supports open shadow roots.\"));\n          }\n        }\n      }\n    }\n  });\n  Cstr.is = cmpMeta.$tagName$;\n  return proxyComponent(Cstr, cmpMeta);\n};\n\n// src/runtime/nonce.ts\nvar setNonce = nonce => plt.$nonce$ = nonce;\n\n// src/runtime/platform-options.ts\nvar setPlatformOptions = opts => Object.assign(plt, opts);\n\n// src/runtime/render.ts\nfunction render(vnode, container) {\n  const cmpMeta = {\n    $flags$: 0,\n    $tagName$: container.tagName\n  };\n  const ref = {\n    $cmpMeta$: cmpMeta,\n    $hostElement$: container\n  };\n  renderVdom(ref, vnode);\n}\nlet CACHED_MAP;\nconst getIconMap = () => {\n  if (typeof window === 'undefined') {\n    return new Map();\n  } else {\n    if (!CACHED_MAP) {\n      const win = window;\n      win.Ionicons = win.Ionicons || {};\n      CACHED_MAP = win.Ionicons.map = win.Ionicons.map || new Map();\n    }\n    return CACHED_MAP;\n  }\n};\nconst addIcons = icons => {\n  Object.keys(icons).forEach(name => {\n    addToIconMap(name, icons[name]);\n    /**\n     * Developers can also pass in the SVG object directly\n     * and Ionicons can map the object to a kebab case name.\n     * Example: addIcons({ addCircleOutline });\n     * This will create an \"addCircleOutline\" entry and\n     * an \"add-circle-outline\" entry.\n     * Usage: <ion-icon name=\"add-circle-outline\"></ion-icon>\n     * Using name=\"addCircleOutline\" is valid too, but the\n     * kebab case naming is preferred.\n     */\n    const toKebabCase = name.replace(/([a-z0-9]|(?=[A-Z]))([A-Z0-9])/g, '$1-$2').toLowerCase();\n    if (name !== toKebabCase) {\n      addToIconMap(toKebabCase, icons[name]);\n    }\n  });\n};\nconst addToIconMap = (name, data) => {\n  const map = getIconMap();\n  const existingIcon = map.get(name);\n  if (existingIcon === undefined) {\n    map.set(name, data);\n    /**\n     * Importing and defining the same icon reference\n     * multiple times should not yield a warning.\n     */\n  } else if (existingIcon !== data) {\n    console.warn(\"[Ionicons Warning]: Multiple icons were mapped to name \\\"\".concat(name, \"\\\". Ensure that multiple icons are not mapped to the same icon name.\"));\n  }\n};\nconst getUrl = i => {\n  let url = getSrc(i.src);\n  if (url) {\n    return url;\n  }\n  url = getName(i.name, i.icon, i.mode, i.ios, i.md);\n  if (url) {\n    return getNamedUrl(url, i);\n  }\n  if (i.icon) {\n    url = getSrc(i.icon);\n    if (url) {\n      return url;\n    }\n    url = getSrc(i.icon[i.mode]);\n    if (url) {\n      return url;\n    }\n  }\n  return null;\n};\nconst getNamedUrl = (iconName, iconEl) => {\n  const url = getIconMap().get(iconName);\n  if (url) {\n    return url;\n  }\n  try {\n    return getAssetPath(\"svg/\".concat(iconName, \".svg\"));\n  } catch (e) {\n    console.log('e', e);\n    /**\n     * In the custom elements build version of ionicons, referencing an icon\n     * by name will throw an invalid URL error because the asset path is not defined.\n     * This catches that error and logs something that is more developer-friendly.\n     * We also include a reference to the ion-icon element so developers can\n     * figure out which instance of ion-icon needs to be updated.\n     */\n    console.warn(\"[Ionicons Warning]: Could not load icon with name \\\"\".concat(iconName, \"\\\". Ensure that the icon is registered using addIcons or that the icon SVG data is passed directly to the icon component.\"), iconEl);\n  }\n};\nconst getName = (iconName, icon, mode, ios, md) => {\n  // default to \"md\" if somehow the mode wasn't set\n  mode = (mode && toLower(mode)) === 'ios' ? 'ios' : 'md';\n  // if an icon was passed in using the ios or md attributes\n  // set the iconName to whatever was passed in\n  if (ios && mode === 'ios') {\n    iconName = toLower(ios);\n  } else if (md && mode === 'md') {\n    iconName = toLower(md);\n  } else {\n    if (!iconName && icon && !isSrc(icon)) {\n      iconName = icon;\n    }\n    if (isStr(iconName)) {\n      iconName = toLower(iconName);\n    }\n  }\n  if (!isStr(iconName) || iconName.trim() === '') {\n    return null;\n  }\n  // only allow alpha characters and dash\n  const invalidChars = iconName.replace(/[a-z]|-|\\d/gi, '');\n  if (invalidChars !== '') {\n    return null;\n  }\n  return iconName;\n};\nconst getSrc = src => {\n  if (isStr(src)) {\n    src = src.trim();\n    if (isSrc(src)) {\n      return src;\n    }\n  }\n  return null;\n};\nconst isSrc = str => str.length > 0 && /(\\/|\\.)/.test(str);\nconst isStr = val => typeof val === 'string';\nconst toLower = val => val.toLowerCase();\n/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner input in `ion-input` should inherit\n * the `title` attribute that developers set directly on `ion-input`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n */\nconst inheritAttributes = function (el) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const attributeObject = {};\n  attributes.forEach(attr => {\n    if (el.hasAttribute(attr)) {\n      const value = el.getAttribute(attr);\n      if (value !== null) {\n        attributeObject[attr] = el.getAttribute(attr);\n      }\n      el.removeAttribute(attr);\n    }\n  });\n  return attributeObject;\n};\n/**\n * Returns `true` if the document or host element\n * has a `dir` set to `rtl`. The host value will always\n * take priority over the root document value.\n */\nconst isRTL = hostEl => {\n  if (hostEl) {\n    if (hostEl.dir !== '') {\n      return hostEl.dir.toLowerCase() === 'rtl';\n    }\n  }\n  return (document === null || document === void 0 ? void 0 : document.dir.toLowerCase()) === 'rtl';\n};\nexport { H, inheritAttributes as a, addIcons, getName as b, isRTL as c, Host as d, getUrl as g, getAssetPath, h, isStr as i, proxyCustomElement as p, render, setAssetPath, setNonce, setPlatformOptions };","map":{"version":3,"names":["NAMESPACE","BUILD","hydratedSelectorName","lazyLoad","updatable","__defProp","Object","defineProperty","__export","target","all","name","get","enumerable","getHostRef","ref","__stencil__getHostRef","registerHost","hostElement","cmpMeta","hostRef","$flags$","$hostElement$","$cmpMeta$","$instanceValues$","Map","$onReadyPromise$","Promise","r","$onReadyResolve$","isMemberInElement","elm","memberName","consoleError","e","el","console","error","styles","SLOT_FB_CSS","XLINK_NS","win","window","H","HTMLElement","plt","$resourcesUrl$","jmp","h2","raf","requestAnimationFrame","ael","eventName","listener","opts","addEventListener","rel","removeEventListener","ce","CustomEvent","promiseResolve","v","resolve","supportsConstructableStylesheets","CSSStyleSheet","replaceSync","queuePending","queueDomReads","queueDomWrites","queueTask","queue","write","cb","push","nextTick","flush","consume","i2","length","performance","now","then","writeTask","getAssetPath","path","assetUrl","URL","origin","location","href","pathname","setAssetPath","isComplexType","o","queryNonceMetaTagContent","doc","_a","_b","_c","head","querySelector","getAttribute","escapeRegExpSpecialCharacters","text","replace","result_exports","err","map","ok","unwrap","unwrapErr","value","isOk","isErr","result","fn","val","newVal","createStyleSheetIfNeededAndSupported","styles2","globalStyleSheet","createShadowRoot","shadowRoot","attachShadow","mode","adoptedStyleSheets","createTime","fnName","tagName","arguments","undefined","rootAppliedStyles","WeakMap","registerStyle","scopeId2","cssText","allowCS","style","set","addStyle","styleContainerNode","getScopeId","document","nodeType","appliedStyles","styleElm","Set","has","createElement","innerHTML","nonce","$nonce$","setAttribute","nodeName","preconnectLinks","querySelectorAll","referenceNode2","nextSibling","insertBefore","parentNode","stylesheet","unshift","existingStyleContainer","prepend","append","add","includes","attachStyles","flags","endAttachStyles","$tagName$","getRootNode","classList","cmp","h","vnodeData","child","key","simple","lastSimple","vNodeChildren","walk","c","Array","isArray","String","$text$","newVNode","_len","children","_key","classData","className","class","keys","filter","k","join","vnode","$attrs$","$children$","$key$","tag","$tag$","$elm$","Host","isHost","node","createSupportsRuleRe","selector","safeSelector2","RegExp","concat","parsePropertyValue","propValue","propType","isFormAssociated","emitEvent","ev","dispatchEvent","setAccessor","oldValue","newValue","isSvg","initialRender","isProp","ln","toLowerCase","oldClasses","parseClassList","newClasses","remove","prop","removeProperty","setProperty","__lookupSetter__","slice","capture","endsWith","CAPTURE_EVENT_SUFFIX","CAPTURE_EVENT_REGEX","isComplex","n","xlink","removeAttributeNS","removeAttribute","setAttributeNS","parseClassListRegex","baseVal","split","updateElement","oldVnode","newVnode","isSvgMode2","isInitialRender","host","oldVnodeAttrs","newVnodeAttrs","sortedAttrNames","attrNames","attr","hostTagName","isSvgMode","createElm","oldParentVNode","newParentVNode","childIndex","newVNode2","childNode","createTextNode","Error","appendChild","addVnodes","parentElm","before","parentVNode","vnodes","startIdx","endIdx","containerElm","removeVnodes","index","nullifyVNodeRefs","updateChildren","oldCh","newCh","oldStartIdx","newStartIdx","idxInOld","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","elmToMove","isSameVnode","patch","leftVNode","rightVNode","oldVNode","oldChildren","newChildren","textContent","data","vNode","parent","newNode","reference","renderVdom","renderFnResults","isInitialLoad","hostElm","$vnode$","isHostElement","rootVnode","$attrsToReflect$","_ref","propName","attribute","hasAttribute","attachToAncestor","ancestorComponent","$onRenderResolve$","splice","scheduleUpdate","$ancestorComponent$","dispatch","dispatchHooks","endSchedule","instance","maybePromise","safeCall","enqueue","updateComponent","isPromisey","catch","err2","endUpdate","rc","endRender","callRender","childrenPromises","postUpdate","postUpdateComponent","render","endPostUpdate","addHydratedFlag","appDidLoad","who","detail","namespace","method","arg","getValue","setValue","oldVal","$members$","areBothNaN","Number","isNaN","didValueChange","$watchers$","watchMethods","watchMethodName","componentShouldUpdate","proxyComponent","Cstr","prototype","watchers","members","entries","_ref2","memberFlags","origGetter","origSetter","getOwnPropertyDescriptor","apply","configurable","currentValue","attrNameToPropName","attributeChangedCallback","attrName","_a2","hasOwnProperty","flags2","entry","forEach","callbackName","call","propDesc","observedAttributes","from","_ref3","_","m","_ref4","initializeComponent","hmrVersionId","constructor","cmpTag","localName","customElements","whenDefined","endRegisterStyles","schedule","fireConnectedCallback","connectedCallback","endConnected","_ref5","initializeNextTick","$lazyInstance$","disconnectedCallback","delete","proxyCustomElement","compactMeta","originalConnectedCallback","originalDisconnectedCallback","assign","__hasHostListenerAttached","__registerHost","__attachShadow","is","setNonce","setPlatformOptions","container","CACHED_MAP","getIconMap","Ionicons","addIcons","icons","addToIconMap","toKebabCase","existingIcon","warn","getUrl","i","url","getSrc","src","getName","icon","ios","md","getNamedUrl","iconName","iconEl","log","toLower","isSrc","isStr","trim","invalidChars","str","test","inheritAttributes","attributes","attributeObject","isRTL","hostEl","dir","a","b","d","g","p"],"sources":["/home/ubuntu/yanbao-miniprogram/node_modules/@ionic/react/node_modules/ionicons/components/index.js"],"sourcesContent":["const NAMESPACE = 'ionicons';\nconst BUILD = /* ionicons */ { hydratedSelectorName: \"hydrated\", lazyLoad: false, updatable: true};\n\n/*\n Stencil Client Platform v4.35.3 | MIT Licensed | https://stenciljs.com\n */\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/client/client-host-ref.ts\nvar getHostRef = (ref) => {\n  if (ref.__stencil__getHostRef) {\n    return ref.__stencil__getHostRef();\n  }\n  return void 0;\n};\nvar registerHost = (hostElement, cmpMeta) => {\n  const hostRef = {\n    $flags$: 0,\n    $hostElement$: hostElement,\n    $cmpMeta$: cmpMeta,\n    $instanceValues$: /* @__PURE__ */ new Map()\n  };\n  {\n    hostRef.$onReadyPromise$ = new Promise((r) => hostRef.$onReadyResolve$ = r);\n    hostElement[\"s-p\"] = [];\n    hostElement[\"s-rc\"] = [];\n  }\n  const ref = hostRef;\n  hostElement.__stencil__getHostRef = () => ref;\n  return ref;\n};\nvar isMemberInElement = (elm, memberName) => memberName in elm;\nvar consoleError = (e, el) => (0, console.error)(e, el);\n\n// src/client/client-style.ts\nvar styles = /* @__PURE__ */ new Map();\nvar SLOT_FB_CSS = \"slot-fb{display:contents}slot-fb[hidden]{display:none}\";\nvar XLINK_NS = \"http://www.w3.org/1999/xlink\";\nvar win = typeof window !== \"undefined\" ? window : {};\nvar H = win.HTMLElement || class {\n};\nvar plt = {\n  $flags$: 0,\n  $resourcesUrl$: \"\",\n  jmp: (h2) => h2(),\n  raf: (h2) => requestAnimationFrame(h2),\n  ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\n  rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),\n  ce: (eventName, opts) => new CustomEvent(eventName, opts)\n};\nvar promiseResolve = (v) => Promise.resolve(v);\nvar supportsConstructableStylesheets = /* @__PURE__ */ (() => {\n  try {\n    new CSSStyleSheet();\n    return typeof new CSSStyleSheet().replaceSync === \"function\";\n  } catch (e) {\n  }\n  return false;\n})() ;\nvar queuePending = false;\nvar queueDomReads = [];\nvar queueDomWrites = [];\nvar queueTask = (queue, write) => (cb) => {\n  queue.push(cb);\n  if (!queuePending) {\n    queuePending = true;\n    if (write && plt.$flags$ & 4 /* queueSync */) {\n      nextTick(flush);\n    } else {\n      plt.raf(flush);\n    }\n  }\n};\nvar consume = (queue) => {\n  for (let i2 = 0; i2 < queue.length; i2++) {\n    try {\n      queue[i2](performance.now());\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n  queue.length = 0;\n};\nvar flush = () => {\n  consume(queueDomReads);\n  {\n    consume(queueDomWrites);\n    if (queuePending = queueDomReads.length > 0) {\n      plt.raf(flush);\n    }\n  }\n};\nvar nextTick = (cb) => promiseResolve().then(cb);\nvar writeTask = /* @__PURE__ */ queueTask(queueDomWrites, true);\n\n// src/runtime/asset-path.ts\nvar getAssetPath = (path) => {\n  const assetUrl = new URL(path, plt.$resourcesUrl$);\n  return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;\n};\nvar setAssetPath = (path) => plt.$resourcesUrl$ = path;\nvar isComplexType = (o) => {\n  o = typeof o;\n  return o === \"object\" || o === \"function\";\n};\n\n// src/utils/query-nonce-meta-tag-content.ts\nfunction queryNonceMetaTagContent(doc) {\n  var _a, _b, _c;\n  return (_c = (_b = (_a = doc.head) == null ? void 0 : _a.querySelector('meta[name=\"csp-nonce\"]')) == null ? void 0 : _b.getAttribute(\"content\")) != null ? _c : void 0;\n}\n\n// src/utils/regular-expression.ts\nvar escapeRegExpSpecialCharacters = (text) => {\n  return text.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n};\n\n// src/utils/result.ts\nvar result_exports = {};\n__export(result_exports, {\n  err: () => err,\n  map: () => map,\n  ok: () => ok,\n  unwrap: () => unwrap,\n  unwrapErr: () => unwrapErr\n});\nvar ok = (value) => ({\n  isOk: true,\n  isErr: false,\n  value\n});\nvar err = (value) => ({\n  isOk: false,\n  isErr: true,\n  value\n});\nfunction map(result, fn) {\n  if (result.isOk) {\n    const val = fn(result.value);\n    if (val instanceof Promise) {\n      return val.then((newVal) => ok(newVal));\n    } else {\n      return ok(val);\n    }\n  }\n  if (result.isErr) {\n    const value = result.value;\n    return err(value);\n  }\n  throw \"should never get here\";\n}\nvar unwrap = (result) => {\n  if (result.isOk) {\n    return result.value;\n  } else {\n    throw result.value;\n  }\n};\nvar unwrapErr = (result) => {\n  if (result.isErr) {\n    return result.value;\n  } else {\n    throw result.value;\n  }\n};\n\n// src/utils/style.ts\nfunction createStyleSheetIfNeededAndSupported(styles2) {\n  return void 0;\n}\n\n// src/utils/shadow-root.ts\nvar globalStyleSheet;\nfunction createShadowRoot(cmpMeta) {\n  var _a;\n  const shadowRoot = this.attachShadow({ mode: \"open\" });\n  if (globalStyleSheet === void 0) globalStyleSheet = (_a = createStyleSheetIfNeededAndSupported()) != null ? _a : null;\n  if (globalStyleSheet) shadowRoot.adoptedStyleSheets.push(globalStyleSheet);\n}\nvar createTime = (fnName, tagName = \"\") => {\n  {\n    return () => {\n      return;\n    };\n  }\n};\nvar rootAppliedStyles = /* @__PURE__ */ new WeakMap();\nvar registerStyle = (scopeId2, cssText, allowCS) => {\n  let style = styles.get(scopeId2);\n  if (supportsConstructableStylesheets && allowCS) {\n    style = style || new CSSStyleSheet();\n    if (typeof style === \"string\") {\n      style = cssText;\n    } else {\n      style.replaceSync(cssText);\n    }\n  } else {\n    style = cssText;\n  }\n  styles.set(scopeId2, style);\n};\nvar addStyle = (styleContainerNode, cmpMeta, mode) => {\n  var _a;\n  const scopeId2 = getScopeId(cmpMeta);\n  const style = styles.get(scopeId2);\n  if (!win.document) {\n    return scopeId2;\n  }\n  styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : win.document;\n  if (style) {\n    if (typeof style === \"string\") {\n      styleContainerNode = styleContainerNode.head || styleContainerNode;\n      let appliedStyles = rootAppliedStyles.get(styleContainerNode);\n      let styleElm;\n      if (!appliedStyles) {\n        rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());\n      }\n      if (!appliedStyles.has(scopeId2)) {\n        {\n          styleElm = win.document.createElement(\"style\");\n          styleElm.innerHTML = style;\n          const nonce = (_a = plt.$nonce$) != null ? _a : queryNonceMetaTagContent(win.document);\n          if (nonce != null) {\n            styleElm.setAttribute(\"nonce\", nonce);\n          }\n          if (!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */)) {\n            if (styleContainerNode.nodeName === \"HEAD\") {\n              const preconnectLinks = styleContainerNode.querySelectorAll(\"link[rel=preconnect]\");\n              const referenceNode2 = preconnectLinks.length > 0 ? preconnectLinks[preconnectLinks.length - 1].nextSibling : styleContainerNode.querySelector(\"style\");\n              styleContainerNode.insertBefore(\n                styleElm,\n                (referenceNode2 == null ? void 0 : referenceNode2.parentNode) === styleContainerNode ? referenceNode2 : null\n              );\n            } else if (\"host\" in styleContainerNode) {\n              if (supportsConstructableStylesheets) {\n                const stylesheet = new CSSStyleSheet();\n                stylesheet.replaceSync(style);\n                styleContainerNode.adoptedStyleSheets.unshift(stylesheet);\n              } else {\n                const existingStyleContainer = styleContainerNode.querySelector(\"style\");\n                if (existingStyleContainer) {\n                  existingStyleContainer.innerHTML = style + existingStyleContainer.innerHTML;\n                } else {\n                  styleContainerNode.prepend(styleElm);\n                }\n              }\n            } else {\n              styleContainerNode.append(styleElm);\n            }\n          }\n          if (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n            styleContainerNode.insertBefore(styleElm, null);\n          }\n        }\n        if (cmpMeta.$flags$ & 4 /* hasSlotRelocation */) {\n          styleElm.innerHTML += SLOT_FB_CSS;\n        }\n        if (appliedStyles) {\n          appliedStyles.add(scopeId2);\n        }\n      }\n    } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {\n      styleContainerNode.adoptedStyleSheets.push(style);\n    }\n  }\n  return scopeId2;\n};\nvar attachStyles = (hostRef) => {\n  const cmpMeta = hostRef.$cmpMeta$;\n  const elm = hostRef.$hostElement$;\n  const flags = cmpMeta.$flags$;\n  const endAttachStyles = createTime(\"attachStyles\", cmpMeta.$tagName$);\n  const scopeId2 = addStyle(\n    elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(),\n    cmpMeta);\n  if (flags & 10 /* needsScopedEncapsulation */) {\n    elm[\"s-sc\"] = scopeId2;\n    elm.classList.add(scopeId2 + \"-h\");\n  }\n  endAttachStyles();\n};\nvar getScopeId = (cmp, mode) => \"sc-\" + (cmp.$tagName$);\nvar h = (nodeName, vnodeData, ...children) => {\n  let child = null;\n  let key = null;\n  let simple = false;\n  let lastSimple = false;\n  const vNodeChildren = [];\n  const walk = (c) => {\n    for (let i2 = 0; i2 < c.length; i2++) {\n      child = c[i2];\n      if (Array.isArray(child)) {\n        walk(child);\n      } else if (child != null && typeof child !== \"boolean\") {\n        if (simple = typeof nodeName !== \"function\" && !isComplexType(child)) {\n          child = String(child);\n        }\n        if (simple && lastSimple) {\n          vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n        } else {\n          vNodeChildren.push(simple ? newVNode(null, child) : child);\n        }\n        lastSimple = simple;\n      }\n    }\n  };\n  walk(children);\n  if (vnodeData) {\n    if (vnodeData.key) {\n      key = vnodeData.key;\n    }\n    {\n      const classData = vnodeData.className || vnodeData.class;\n      if (classData) {\n        vnodeData.class = typeof classData !== \"object\" ? classData : Object.keys(classData).filter((k) => classData[k]).join(\" \");\n      }\n    }\n  }\n  const vnode = newVNode(nodeName, null);\n  vnode.$attrs$ = vnodeData;\n  if (vNodeChildren.length > 0) {\n    vnode.$children$ = vNodeChildren;\n  }\n  {\n    vnode.$key$ = key;\n  }\n  return vnode;\n};\nvar newVNode = (tag, text) => {\n  const vnode = {\n    $flags$: 0,\n    $tag$: tag,\n    $text$: text,\n    $elm$: null,\n    $children$: null\n  };\n  {\n    vnode.$attrs$ = null;\n  }\n  {\n    vnode.$key$ = null;\n  }\n  return vnode;\n};\nvar Host = {};\nvar isHost = (node) => node && node.$tag$ === Host;\nvar createSupportsRuleRe = (selector) => {\n  const safeSelector2 = escapeRegExpSpecialCharacters(selector);\n  return new RegExp(\n    // First capture group: match any context before the selector that's not inside @supports selector()\n    // Using negative lookahead to avoid matching inside @supports selector(...) condition\n    `(^|[^@]|@(?!supports\\\\s+selector\\\\s*\\\\([^{]*?${safeSelector2}))(${safeSelector2}\\\\b)`,\n    \"g\"\n  );\n};\ncreateSupportsRuleRe(\"::slotted\");\ncreateSupportsRuleRe(\":host\");\ncreateSupportsRuleRe(\":host-context\");\nvar parsePropertyValue = (propValue, propType, isFormAssociated) => {\n  if (propValue != null && !isComplexType(propValue)) {\n    if (propType & 4 /* Boolean */) {\n      {\n        return propValue === \"false\" ? false : propValue === \"\" || !!propValue;\n      }\n    }\n    if (propType & 1 /* String */) {\n      return String(propValue);\n    }\n    return propValue;\n  }\n  return propValue;\n};\nvar emitEvent = (elm, name, opts) => {\n  const ev = plt.ce(name, opts);\n  elm.dispatchEvent(ev);\n  return ev;\n};\nvar setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags, initialRender) => {\n  if (oldValue === newValue) {\n    return;\n  }\n  let isProp = isMemberInElement(elm, memberName);\n  let ln = memberName.toLowerCase();\n  if (memberName === \"class\") {\n    const classList = elm.classList;\n    const oldClasses = parseClassList(oldValue);\n    let newClasses = parseClassList(newValue);\n    {\n      classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));\n      classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));\n    }\n  } else if (memberName === \"style\") {\n    {\n      for (const prop in oldValue) {\n        if (!newValue || newValue[prop] == null) {\n          if (prop.includes(\"-\")) {\n            elm.style.removeProperty(prop);\n          } else {\n            elm.style[prop] = \"\";\n          }\n        }\n      }\n    }\n    for (const prop in newValue) {\n      if (!oldValue || newValue[prop] !== oldValue[prop]) {\n        if (prop.includes(\"-\")) {\n          elm.style.setProperty(prop, newValue[prop]);\n        } else {\n          elm.style[prop] = newValue[prop];\n        }\n      }\n    }\n  } else if (memberName === \"key\") ; else if (memberName === \"ref\") {\n    if (newValue) {\n      newValue(elm);\n    }\n  } else if ((!elm.__lookupSetter__(memberName)) && memberName[0] === \"o\" && memberName[1] === \"n\") {\n    if (memberName[2] === \"-\") {\n      memberName = memberName.slice(3);\n    } else if (isMemberInElement(win, ln)) {\n      memberName = ln.slice(2);\n    } else {\n      memberName = ln[2] + memberName.slice(3);\n    }\n    if (oldValue || newValue) {\n      const capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX);\n      memberName = memberName.replace(CAPTURE_EVENT_REGEX, \"\");\n      if (oldValue) {\n        plt.rel(elm, memberName, oldValue, capture);\n      }\n      if (newValue) {\n        plt.ael(elm, memberName, newValue, capture);\n      }\n    }\n  } else {\n    const isComplex = isComplexType(newValue);\n    if ((isProp || isComplex && newValue !== null) && true) {\n      try {\n        if (!elm.tagName.includes(\"-\")) {\n          const n = newValue == null ? \"\" : newValue;\n          if (memberName === \"list\") {\n            isProp = false;\n          } else if (oldValue == null || elm[memberName] != n) {\n            if (typeof elm.__lookupSetter__(memberName) === \"function\") {\n              elm[memberName] = n;\n            } else {\n              elm.setAttribute(memberName, n);\n            }\n          }\n        } else if (elm[memberName] !== newValue) {\n          elm[memberName] = newValue;\n        }\n      } catch (e) {\n      }\n    }\n    let xlink = false;\n    {\n      if (ln !== (ln = ln.replace(/^xlink\\:?/, \"\"))) {\n        memberName = ln;\n        xlink = true;\n      }\n    }\n    if (newValue == null || newValue === false) {\n      if (newValue !== false || elm.getAttribute(memberName) === \"\") {\n        if (xlink) {\n          elm.removeAttributeNS(XLINK_NS, memberName);\n        } else {\n          elm.removeAttribute(memberName);\n        }\n      }\n    } else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex && elm.nodeType === 1 /* ElementNode */) {\n      newValue = newValue === true ? \"\" : newValue;\n      if (xlink) {\n        elm.setAttributeNS(XLINK_NS, memberName, newValue);\n      } else {\n        elm.setAttribute(memberName, newValue);\n      }\n    }\n  }\n};\nvar parseClassListRegex = /\\s/;\nvar parseClassList = (value) => {\n  if (typeof value === \"object\" && value && \"baseVal\" in value) {\n    value = value.baseVal;\n  }\n  if (!value || typeof value !== \"string\") {\n    return [];\n  }\n  return value.split(parseClassListRegex);\n};\nvar CAPTURE_EVENT_SUFFIX = \"Capture\";\nvar CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + \"$\");\n\n// src/runtime/vdom/update-element.ts\nvar updateElement = (oldVnode, newVnode, isSvgMode2, isInitialRender) => {\n  const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;\n  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || {};\n  const newVnodeAttrs = newVnode.$attrs$ || {};\n  {\n    for (const memberName of sortedAttrNames(Object.keys(oldVnodeAttrs))) {\n      if (!(memberName in newVnodeAttrs)) {\n        setAccessor(\n          elm,\n          memberName,\n          oldVnodeAttrs[memberName],\n          void 0,\n          isSvgMode2,\n          newVnode.$flags$);\n      }\n    }\n  }\n  for (const memberName of sortedAttrNames(Object.keys(newVnodeAttrs))) {\n    setAccessor(\n      elm,\n      memberName,\n      oldVnodeAttrs[memberName],\n      newVnodeAttrs[memberName],\n      isSvgMode2,\n      newVnode.$flags$);\n  }\n};\nfunction sortedAttrNames(attrNames) {\n  return attrNames.includes(\"ref\") ? (\n    // we need to sort these to ensure that `'ref'` is the last attr\n    [...attrNames.filter((attr) => attr !== \"ref\"), \"ref\"]\n  ) : (\n    // no need to sort, return the original array\n    attrNames\n  );\n}\nvar hostTagName;\nvar isSvgMode = false;\nvar createElm = (oldParentVNode, newParentVNode, childIndex) => {\n  const newVNode2 = newParentVNode.$children$[childIndex];\n  let i2 = 0;\n  let elm;\n  let childNode;\n  if (newVNode2.$text$ !== null) {\n    elm = newVNode2.$elm$ = win.document.createTextNode(newVNode2.$text$);\n  } else {\n    if (!win.document) {\n      throw new Error(\n        \"You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component.\"\n      );\n    }\n    elm = newVNode2.$elm$ = win.document.createElement(\n      newVNode2.$tag$\n    );\n    {\n      updateElement(null, newVNode2, isSvgMode);\n    }\n    if (newVNode2.$children$) {\n      for (i2 = 0; i2 < newVNode2.$children$.length; ++i2) {\n        childNode = createElm(oldParentVNode, newVNode2, i2);\n        if (childNode) {\n          elm.appendChild(childNode);\n        }\n      }\n    }\n  }\n  elm[\"s-hn\"] = hostTagName;\n  return elm;\n};\nvar addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\n  let containerElm = parentElm;\n  let childNode;\n  if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n    containerElm = containerElm.shadowRoot;\n  }\n  for (; startIdx <= endIdx; ++startIdx) {\n    if (vnodes[startIdx]) {\n      childNode = createElm(null, parentVNode, startIdx);\n      if (childNode) {\n        vnodes[startIdx].$elm$ = childNode;\n        insertBefore(containerElm, childNode, before);\n      }\n    }\n  }\n};\nvar removeVnodes = (vnodes, startIdx, endIdx) => {\n  for (let index = startIdx; index <= endIdx; ++index) {\n    const vnode = vnodes[index];\n    if (vnode) {\n      const elm = vnode.$elm$;\n      nullifyVNodeRefs(vnode);\n      if (elm) {\n        elm.remove();\n      }\n    }\n  }\n};\nvar updateChildren = (parentElm, oldCh, newVNode2, newCh, isInitialRender = false) => {\n  let oldStartIdx = 0;\n  let newStartIdx = 0;\n  let idxInOld = 0;\n  let i2 = 0;\n  let oldEndIdx = oldCh.length - 1;\n  let oldStartVnode = oldCh[0];\n  let oldEndVnode = oldCh[oldEndIdx];\n  let newEndIdx = newCh.length - 1;\n  let newStartVnode = newCh[0];\n  let newEndVnode = newCh[newEndIdx];\n  let node;\n  let elmToMove;\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (oldStartVnode == null) {\n      oldStartVnode = oldCh[++oldStartIdx];\n    } else if (oldEndVnode == null) {\n      oldEndVnode = oldCh[--oldEndIdx];\n    } else if (newStartVnode == null) {\n      newStartVnode = newCh[++newStartIdx];\n    } else if (newEndVnode == null) {\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {\n      patch(oldStartVnode, newStartVnode, isInitialRender);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {\n      patch(oldEndVnode, newEndVnode, isInitialRender);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {\n      patch(oldStartVnode, newEndVnode, isInitialRender);\n      insertBefore(parentElm, oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {\n      patch(oldEndVnode, newStartVnode, isInitialRender);\n      insertBefore(parentElm, oldEndVnode.$elm$, oldStartVnode.$elm$);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else {\n      idxInOld = -1;\n      {\n        for (i2 = oldStartIdx; i2 <= oldEndIdx; ++i2) {\n          if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {\n            idxInOld = i2;\n            break;\n          }\n        }\n      }\n      if (idxInOld >= 0) {\n        elmToMove = oldCh[idxInOld];\n        if (elmToMove.$tag$ !== newStartVnode.$tag$) {\n          node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld);\n        } else {\n          patch(elmToMove, newStartVnode, isInitialRender);\n          oldCh[idxInOld] = void 0;\n          node = elmToMove.$elm$;\n        }\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx);\n        newStartVnode = newCh[++newStartIdx];\n      }\n      if (node) {\n        {\n          insertBefore(oldStartVnode.$elm$.parentNode, node, oldStartVnode.$elm$);\n        }\n      }\n    }\n  }\n  if (oldStartIdx > oldEndIdx) {\n    addVnodes(\n      parentElm,\n      newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$,\n      newVNode2,\n      newCh,\n      newStartIdx,\n      newEndIdx\n    );\n  } else if (newStartIdx > newEndIdx) {\n    removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n  }\n};\nvar isSameVnode = (leftVNode, rightVNode, isInitialRender = false) => {\n  if (leftVNode.$tag$ === rightVNode.$tag$) {\n    if (!isInitialRender) {\n      return leftVNode.$key$ === rightVNode.$key$;\n    }\n    if (isInitialRender && !leftVNode.$key$ && rightVNode.$key$) {\n      leftVNode.$key$ = rightVNode.$key$;\n    }\n    return true;\n  }\n  return false;\n};\nvar patch = (oldVNode, newVNode2, isInitialRender = false) => {\n  const elm = newVNode2.$elm$ = oldVNode.$elm$;\n  const oldChildren = oldVNode.$children$;\n  const newChildren = newVNode2.$children$;\n  const text = newVNode2.$text$;\n  if (text === null) {\n    {\n      updateElement(oldVNode, newVNode2, isSvgMode);\n    }\n    if (oldChildren !== null && newChildren !== null) {\n      updateChildren(elm, oldChildren, newVNode2, newChildren, isInitialRender);\n    } else if (newChildren !== null) {\n      if (oldVNode.$text$ !== null) {\n        elm.textContent = \"\";\n      }\n      addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);\n    } else if (\n      // don't do this on initial render as it can cause non-hydrated content to be removed\n      !isInitialRender && BUILD.updatable && oldChildren !== null\n    ) {\n      removeVnodes(oldChildren, 0, oldChildren.length - 1);\n    } else ;\n  } else if (oldVNode.$text$ !== text) {\n    elm.data = text;\n  }\n};\nvar nullifyVNodeRefs = (vNode) => {\n  {\n    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n    vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);\n  }\n};\nvar insertBefore = (parent, newNode, reference) => {\n  {\n    return parent == null ? void 0 : parent.insertBefore(newNode, reference);\n  }\n};\nvar renderVdom = (hostRef, renderFnResults, isInitialLoad = false) => {\n  const hostElm = hostRef.$hostElement$;\n  const cmpMeta = hostRef.$cmpMeta$;\n  const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n  const isHostElement = isHost(renderFnResults);\n  const rootVnode = isHostElement ? renderFnResults : h(null, null, renderFnResults);\n  hostTagName = hostElm.tagName;\n  if (cmpMeta.$attrsToReflect$) {\n    rootVnode.$attrs$ = rootVnode.$attrs$ || {};\n    cmpMeta.$attrsToReflect$.map(\n      ([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]\n    );\n  }\n  if (isInitialLoad && rootVnode.$attrs$) {\n    for (const key of Object.keys(rootVnode.$attrs$)) {\n      if (hostElm.hasAttribute(key) && ![\"key\", \"ref\", \"style\", \"class\"].includes(key)) {\n        rootVnode.$attrs$[key] = hostElm[key];\n      }\n    }\n  }\n  rootVnode.$tag$ = null;\n  rootVnode.$flags$ |= 4 /* isHost */;\n  hostRef.$vnode$ = rootVnode;\n  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm ;\n  patch(oldVNode, rootVnode, isInitialLoad);\n};\n\n// src/runtime/update-component.ts\nvar attachToAncestor = (hostRef, ancestorComponent) => {\n  if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent[\"s-p\"]) {\n    const index = ancestorComponent[\"s-p\"].push(\n      new Promise(\n        (r) => hostRef.$onRenderResolve$ = () => {\n          ancestorComponent[\"s-p\"].splice(index - 1, 1);\n          r();\n        }\n      )\n    );\n  }\n};\nvar scheduleUpdate = (hostRef, isInitialLoad) => {\n  {\n    hostRef.$flags$ |= 16 /* isQueuedForUpdate */;\n  }\n  if (hostRef.$flags$ & 4 /* isWaitingForChildren */) {\n    hostRef.$flags$ |= 512 /* needsRerender */;\n    return;\n  }\n  attachToAncestor(hostRef, hostRef.$ancestorComponent$);\n  const dispatch = () => dispatchHooks(hostRef, isInitialLoad);\n  return writeTask(dispatch) ;\n};\nvar dispatchHooks = (hostRef, isInitialLoad) => {\n  const elm = hostRef.$hostElement$;\n  const endSchedule = createTime(\"scheduleUpdate\", hostRef.$cmpMeta$.$tagName$);\n  const instance = elm;\n  if (!instance) {\n    throw new Error(\n      `Can't render component <${elm.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \\`externalRuntime: true\\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`\n    );\n  }\n  let maybePromise;\n  if (isInitialLoad) {\n    maybePromise = safeCall(instance, \"componentWillLoad\", void 0, elm);\n  } else {\n    maybePromise = safeCall(instance, \"componentWillUpdate\", void 0, elm);\n  }\n  maybePromise = enqueue(maybePromise, () => safeCall(instance, \"componentWillRender\", void 0, elm));\n  endSchedule();\n  return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));\n};\nvar enqueue = (maybePromise, fn) => isPromisey(maybePromise) ? maybePromise.then(fn).catch((err2) => {\n  console.error(err2);\n  fn();\n}) : fn();\nvar isPromisey = (maybePromise) => maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === \"function\";\nvar updateComponent = async (hostRef, instance, isInitialLoad) => {\n  var _a;\n  const elm = hostRef.$hostElement$;\n  const endUpdate = createTime(\"update\", hostRef.$cmpMeta$.$tagName$);\n  const rc = elm[\"s-rc\"];\n  if (isInitialLoad) {\n    attachStyles(hostRef);\n  }\n  const endRender = createTime(\"render\", hostRef.$cmpMeta$.$tagName$);\n  {\n    callRender(hostRef, instance, elm, isInitialLoad);\n  }\n  if (rc) {\n    rc.map((cb) => cb());\n    elm[\"s-rc\"] = void 0;\n  }\n  endRender();\n  endUpdate();\n  {\n    const childrenPromises = (_a = elm[\"s-p\"]) != null ? _a : [];\n    const postUpdate = () => postUpdateComponent(hostRef);\n    if (childrenPromises.length === 0) {\n      postUpdate();\n    } else {\n      Promise.all(childrenPromises).then(postUpdate);\n      hostRef.$flags$ |= 4 /* isWaitingForChildren */;\n      childrenPromises.length = 0;\n    }\n  }\n};\nvar callRender = (hostRef, instance, elm, isInitialLoad) => {\n  try {\n    instance = instance.render() ;\n    {\n      hostRef.$flags$ &= -17 /* isQueuedForUpdate */;\n    }\n    {\n      hostRef.$flags$ |= 2 /* hasRendered */;\n    }\n    {\n      {\n        {\n          renderVdom(hostRef, instance, isInitialLoad);\n        }\n      }\n    }\n  } catch (e) {\n    consoleError(e, hostRef.$hostElement$);\n  }\n  return null;\n};\nvar postUpdateComponent = (hostRef) => {\n  const tagName = hostRef.$cmpMeta$.$tagName$;\n  const elm = hostRef.$hostElement$;\n  const endPostUpdate = createTime(\"postUpdate\", tagName);\n  const instance = elm;\n  const ancestorComponent = hostRef.$ancestorComponent$;\n  safeCall(instance, \"componentDidRender\", void 0, elm);\n  if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {\n    hostRef.$flags$ |= 64 /* hasLoadedComponent */;\n    {\n      addHydratedFlag(elm);\n    }\n    safeCall(instance, \"componentDidLoad\", void 0, elm);\n    endPostUpdate();\n    {\n      hostRef.$onReadyResolve$(elm);\n      if (!ancestorComponent) {\n        appDidLoad();\n      }\n    }\n  } else {\n    safeCall(instance, \"componentDidUpdate\", void 0, elm);\n    endPostUpdate();\n  }\n  {\n    if (hostRef.$onRenderResolve$) {\n      hostRef.$onRenderResolve$();\n      hostRef.$onRenderResolve$ = void 0;\n    }\n    if (hostRef.$flags$ & 512 /* needsRerender */) {\n      nextTick(() => scheduleUpdate(hostRef, false));\n    }\n    hostRef.$flags$ &= -517;\n  }\n};\nvar appDidLoad = (who) => {\n  nextTick(() => emitEvent(win, \"appload\", { detail: { namespace: NAMESPACE } }));\n};\nvar safeCall = (instance, method, arg, elm) => {\n  if (instance && instance[method]) {\n    try {\n      return instance[method](arg);\n    } catch (e) {\n      consoleError(e, elm);\n    }\n  }\n  return void 0;\n};\nvar addHydratedFlag = (elm) => {\n  var _a;\n  return elm.classList.add((_a = BUILD.hydratedSelectorName) != null ? _a : \"hydrated\") ;\n};\n\n// src/runtime/set-value.ts\nvar getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\nvar setValue = (ref, propName, newVal, cmpMeta) => {\n  const hostRef = getHostRef(ref);\n  const elm = ref;\n  const oldVal = hostRef.$instanceValues$.get(propName);\n  const flags = hostRef.$flags$;\n  const instance = elm;\n  newVal = parsePropertyValue(\n    newVal,\n    cmpMeta.$members$[propName][0]);\n  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);\n  const didValueChange = newVal !== oldVal && !areBothNaN;\n  if (didValueChange) {\n    hostRef.$instanceValues$.set(propName, newVal);\n    {\n      if (cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {\n        const watchMethods = cmpMeta.$watchers$[propName];\n        if (watchMethods) {\n          watchMethods.map((watchMethodName) => {\n            try {\n              instance[watchMethodName](newVal, oldVal, propName);\n            } catch (e) {\n              consoleError(e, elm);\n            }\n          });\n        }\n      }\n      if ((flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n        if (instance.componentShouldUpdate) {\n          if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {\n            return;\n          }\n        }\n        scheduleUpdate(hostRef, false);\n      }\n    }\n  }\n};\n\n// src/runtime/proxy-component.ts\nvar proxyComponent = (Cstr, cmpMeta, flags) => {\n  var _a, _b;\n  const prototype = Cstr.prototype;\n  if (cmpMeta.$members$ || (cmpMeta.$watchers$ || Cstr.watchers)) {\n    if (Cstr.watchers && !cmpMeta.$watchers$) {\n      cmpMeta.$watchers$ = Cstr.watchers;\n    }\n    const members = Object.entries((_a = cmpMeta.$members$) != null ? _a : {});\n    members.map(([memberName, [memberFlags]]) => {\n      if ((memberFlags & 31 /* Prop */ || memberFlags & 32 /* State */)) {\n        const { get: origGetter, set: origSetter } = Object.getOwnPropertyDescriptor(prototype, memberName) || {};\n        if (origGetter) cmpMeta.$members$[memberName][0] |= 2048 /* Getter */;\n        if (origSetter) cmpMeta.$members$[memberName][0] |= 4096 /* Setter */;\n        {\n          Object.defineProperty(prototype, memberName, {\n            get() {\n              {\n                return origGetter ? origGetter.apply(this) : getValue(this, memberName);\n              }\n            },\n            configurable: true,\n            enumerable: true\n          });\n        }\n        Object.defineProperty(prototype, memberName, {\n          set(newValue) {\n            const ref = getHostRef(this);\n            if (origSetter) {\n              const currentValue = memberFlags & 32 /* State */ ? this[memberName] : ref.$hostElement$[memberName];\n              if (typeof currentValue === \"undefined\" && ref.$instanceValues$.get(memberName)) {\n                newValue = ref.$instanceValues$.get(memberName);\n              } else if (!ref.$instanceValues$.get(memberName) && currentValue) {\n                ref.$instanceValues$.set(memberName, currentValue);\n              }\n              origSetter.apply(this, [\n                parsePropertyValue(\n                  newValue,\n                  memberFlags)\n              ]);\n              newValue = memberFlags & 32 /* State */ ? this[memberName] : ref.$hostElement$[memberName];\n              setValue(this, memberName, newValue, cmpMeta);\n              return;\n            }\n            {\n              setValue(this, memberName, newValue, cmpMeta);\n              return;\n            }\n          }\n        });\n      }\n    });\n    {\n      const attrNameToPropName = /* @__PURE__ */ new Map();\n      prototype.attributeChangedCallback = function(attrName, oldValue, newValue) {\n        plt.jmp(() => {\n          var _a2;\n          const propName = attrNameToPropName.get(attrName);\n          if (this.hasOwnProperty(propName) && BUILD.lazyLoad) ; else if (prototype.hasOwnProperty(propName) && typeof this[propName] === \"number\" && // cast type to number to avoid TS compiler issues\n          this[propName] == newValue) {\n            return;\n          } else if (propName == null) {\n            const hostRef = getHostRef(this);\n            const flags2 = hostRef == null ? void 0 : hostRef.$flags$;\n            if (flags2 && !(flags2 & 8 /* isConstructingInstance */) && flags2 & 128 /* isWatchReady */ && newValue !== oldValue) {\n              const elm = this;\n              const instance = elm;\n              const entry = (_a2 = cmpMeta.$watchers$) == null ? void 0 : _a2[attrName];\n              entry == null ? void 0 : entry.forEach((callbackName) => {\n                if (instance[callbackName] != null) {\n                  instance[callbackName].call(instance, newValue, oldValue, attrName);\n                }\n              });\n            }\n            return;\n          }\n          const propDesc = Object.getOwnPropertyDescriptor(prototype, propName);\n          newValue = newValue === null && typeof this[propName] === \"boolean\" ? false : newValue;\n          if (newValue !== this[propName] && (!propDesc.get || !!propDesc.set)) {\n            this[propName] = newValue;\n          }\n        });\n      };\n      Cstr.observedAttributes = Array.from(\n        /* @__PURE__ */ new Set([\n          ...Object.keys((_b = cmpMeta.$watchers$) != null ? _b : {}),\n          ...members.filter(([_, m]) => m[0] & 15 /* HasAttribute */).map(([propName, m]) => {\n            var _a2;\n            const attrName = m[1] || propName;\n            attrNameToPropName.set(attrName, propName);\n            if (m[0] & 512 /* ReflectAttr */) {\n              (_a2 = cmpMeta.$attrsToReflect$) == null ? void 0 : _a2.push([propName, attrName]);\n            }\n            return attrName;\n          })\n        ])\n      );\n    }\n  }\n  return Cstr;\n};\n\n// src/runtime/initialize-component.ts\nvar initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId) => {\n  let Cstr;\n  if ((hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {\n    hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n    {\n      Cstr = elm.constructor;\n      const cmpTag = elm.localName;\n      customElements.whenDefined(cmpTag).then(() => hostRef.$flags$ |= 128 /* isWatchReady */);\n    }\n    if (Cstr && Cstr.style) {\n      let style;\n      if (typeof Cstr.style === \"string\") {\n        style = Cstr.style;\n      }\n      const scopeId2 = getScopeId(cmpMeta);\n      if (!styles.has(scopeId2)) {\n        const endRegisterStyles = createTime(\"registerStyles\", cmpMeta.$tagName$);\n        registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));\n        endRegisterStyles();\n      }\n    }\n  }\n  const ancestorComponent = hostRef.$ancestorComponent$;\n  const schedule = () => scheduleUpdate(hostRef, true);\n  if (ancestorComponent && ancestorComponent[\"s-rc\"]) {\n    ancestorComponent[\"s-rc\"].push(schedule);\n  } else {\n    schedule();\n  }\n};\nvar fireConnectedCallback = (instance, elm) => {\n};\n\n// src/runtime/connected-callback.ts\nvar connectedCallback = (elm) => {\n  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n    const hostRef = getHostRef(elm);\n    const cmpMeta = hostRef.$cmpMeta$;\n    const endConnected = createTime(\"connectedCallback\", cmpMeta.$tagName$);\n    if (!(hostRef.$flags$ & 1 /* hasConnected */)) {\n      hostRef.$flags$ |= 1 /* hasConnected */;\n      {\n        let ancestorComponent = elm;\n        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {\n          if (ancestorComponent[\"s-p\"]) {\n            attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);\n            break;\n          }\n        }\n      }\n      if (cmpMeta.$members$) {\n        Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {\n          if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {\n            const value = elm[memberName];\n            delete elm[memberName];\n            elm[memberName] = value;\n          }\n        });\n      }\n      if (BUILD.initializeNextTick) {\n        nextTick(() => initializeComponent(elm, hostRef, cmpMeta));\n      } else {\n        initializeComponent(elm, hostRef, cmpMeta);\n      }\n    } else {\n      if (hostRef == null ? void 0 : hostRef.$lazyInstance$) ; else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {\n        hostRef.$onReadyPromise$.then(() => fireConnectedCallback());\n      }\n    }\n    endConnected();\n  }\n};\nvar disconnectedCallback = async (elm) => {\n  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n    getHostRef(elm);\n  }\n  if (rootAppliedStyles.has(elm)) {\n    rootAppliedStyles.delete(elm);\n  }\n  if (elm.shadowRoot && rootAppliedStyles.has(elm.shadowRoot)) {\n    rootAppliedStyles.delete(elm.shadowRoot);\n  }\n};\nvar proxyCustomElement = (Cstr, compactMeta) => {\n  const cmpMeta = {\n    $flags$: compactMeta[0],\n    $tagName$: compactMeta[1]\n  };\n  {\n    cmpMeta.$members$ = compactMeta[2];\n  }\n  {\n    cmpMeta.$watchers$ = Cstr.$watchers$;\n  }\n  {\n    cmpMeta.$attrsToReflect$ = [];\n  }\n  const originalConnectedCallback = Cstr.prototype.connectedCallback;\n  const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;\n  Object.assign(Cstr.prototype, {\n    __hasHostListenerAttached: false,\n    __registerHost() {\n      registerHost(this, cmpMeta);\n    },\n    connectedCallback() {\n      if (!this.__hasHostListenerAttached) {\n        getHostRef(this);\n        this.__hasHostListenerAttached = true;\n      }\n      connectedCallback(this);\n      if (originalConnectedCallback) {\n        originalConnectedCallback.call(this);\n      }\n    },\n    disconnectedCallback() {\n      disconnectedCallback(this);\n      if (originalDisconnectedCallback) {\n        originalDisconnectedCallback.call(this);\n      }\n    },\n    __attachShadow() {\n      {\n        if (!this.shadowRoot) {\n          createShadowRoot.call(this, cmpMeta);\n        } else {\n          if (this.shadowRoot.mode !== \"open\") {\n            throw new Error(\n              `Unable to re-use existing shadow root for ${cmpMeta.$tagName$}! Mode is set to ${this.shadowRoot.mode} but Stencil only supports open shadow roots.`\n            );\n          }\n        }\n      }\n    }\n  });\n  Cstr.is = cmpMeta.$tagName$;\n  return proxyComponent(Cstr, cmpMeta);\n};\n\n// src/runtime/nonce.ts\nvar setNonce = (nonce) => plt.$nonce$ = nonce;\n\n// src/runtime/platform-options.ts\nvar setPlatformOptions = (opts) => Object.assign(plt, opts);\n\n// src/runtime/render.ts\nfunction render(vnode, container) {\n  const cmpMeta = {\n    $flags$: 0,\n    $tagName$: container.tagName\n  };\n  const ref = {\n    $cmpMeta$: cmpMeta,\n    $hostElement$: container\n  };\n  renderVdom(ref, vnode);\n}\n\nlet CACHED_MAP;\nconst getIconMap = () => {\n    if (typeof window === 'undefined') {\n        return new Map();\n    }\n    else {\n        if (!CACHED_MAP) {\n            const win = window;\n            win.Ionicons = win.Ionicons || {};\n            CACHED_MAP = win.Ionicons.map = win.Ionicons.map || new Map();\n        }\n        return CACHED_MAP;\n    }\n};\nconst addIcons = (icons) => {\n    Object.keys(icons).forEach((name) => {\n        addToIconMap(name, icons[name]);\n        /**\n         * Developers can also pass in the SVG object directly\n         * and Ionicons can map the object to a kebab case name.\n         * Example: addIcons({ addCircleOutline });\n         * This will create an \"addCircleOutline\" entry and\n         * an \"add-circle-outline\" entry.\n         * Usage: <ion-icon name=\"add-circle-outline\"></ion-icon>\n         * Using name=\"addCircleOutline\" is valid too, but the\n         * kebab case naming is preferred.\n         */\n        const toKebabCase = name.replace(/([a-z0-9]|(?=[A-Z]))([A-Z0-9])/g, '$1-$2').toLowerCase();\n        if (name !== toKebabCase) {\n            addToIconMap(toKebabCase, icons[name]);\n        }\n    });\n};\nconst addToIconMap = (name, data) => {\n    const map = getIconMap();\n    const existingIcon = map.get(name);\n    if (existingIcon === undefined) {\n        map.set(name, data);\n        /**\n         * Importing and defining the same icon reference\n         * multiple times should not yield a warning.\n         */\n    }\n    else if (existingIcon !== data) {\n        console.warn(`[Ionicons Warning]: Multiple icons were mapped to name \"${name}\". Ensure that multiple icons are not mapped to the same icon name.`);\n    }\n};\nconst getUrl = (i) => {\n    let url = getSrc(i.src);\n    if (url) {\n        return url;\n    }\n    url = getName(i.name, i.icon, i.mode, i.ios, i.md);\n    if (url) {\n        return getNamedUrl(url, i);\n    }\n    if (i.icon) {\n        url = getSrc(i.icon);\n        if (url) {\n            return url;\n        }\n        url = getSrc(i.icon[i.mode]);\n        if (url) {\n            return url;\n        }\n    }\n    return null;\n};\nconst getNamedUrl = (iconName, iconEl) => {\n    const url = getIconMap().get(iconName);\n    if (url) {\n        return url;\n    }\n    try {\n        return getAssetPath(`svg/${iconName}.svg`);\n    }\n    catch (e) {\n        console.log('e', e);\n        /**\n         * In the custom elements build version of ionicons, referencing an icon\n         * by name will throw an invalid URL error because the asset path is not defined.\n         * This catches that error and logs something that is more developer-friendly.\n         * We also include a reference to the ion-icon element so developers can\n         * figure out which instance of ion-icon needs to be updated.\n         */\n        console.warn(`[Ionicons Warning]: Could not load icon with name \"${iconName}\". Ensure that the icon is registered using addIcons or that the icon SVG data is passed directly to the icon component.`, iconEl);\n    }\n};\nconst getName = (iconName, icon, mode, ios, md) => {\n    // default to \"md\" if somehow the mode wasn't set\n    mode = (mode && toLower(mode)) === 'ios' ? 'ios' : 'md';\n    // if an icon was passed in using the ios or md attributes\n    // set the iconName to whatever was passed in\n    if (ios && mode === 'ios') {\n        iconName = toLower(ios);\n    }\n    else if (md && mode === 'md') {\n        iconName = toLower(md);\n    }\n    else {\n        if (!iconName && icon && !isSrc(icon)) {\n            iconName = icon;\n        }\n        if (isStr(iconName)) {\n            iconName = toLower(iconName);\n        }\n    }\n    if (!isStr(iconName) || iconName.trim() === '') {\n        return null;\n    }\n    // only allow alpha characters and dash\n    const invalidChars = iconName.replace(/[a-z]|-|\\d/gi, '');\n    if (invalidChars !== '') {\n        return null;\n    }\n    return iconName;\n};\nconst getSrc = (src) => {\n    if (isStr(src)) {\n        src = src.trim();\n        if (isSrc(src)) {\n            return src;\n        }\n    }\n    return null;\n};\nconst isSrc = (str) => str.length > 0 && /(\\/|\\.)/.test(str);\nconst isStr = (val) => typeof val === 'string';\nconst toLower = (val) => val.toLowerCase();\n/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner input in `ion-input` should inherit\n * the `title` attribute that developers set directly on `ion-input`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n */\nconst inheritAttributes = (el, attributes = []) => {\n    const attributeObject = {};\n    attributes.forEach((attr) => {\n        if (el.hasAttribute(attr)) {\n            const value = el.getAttribute(attr);\n            if (value !== null) {\n                attributeObject[attr] = el.getAttribute(attr);\n            }\n            el.removeAttribute(attr);\n        }\n    });\n    return attributeObject;\n};\n/**\n * Returns `true` if the document or host element\n * has a `dir` set to `rtl`. The host value will always\n * take priority over the root document value.\n */\nconst isRTL = (hostEl) => {\n    if (hostEl) {\n        if (hostEl.dir !== '') {\n            return hostEl.dir.toLowerCase() === 'rtl';\n        }\n    }\n    return (document === null || document === void 0 ? void 0 : document.dir.toLowerCase()) === 'rtl';\n};\n\nexport { H, inheritAttributes as a, addIcons, getName as b, isRTL as c, Host as d, getUrl as g, getAssetPath, h, isStr as i, proxyCustomElement as p, render, setAssetPath, setNonce, setPlatformOptions };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
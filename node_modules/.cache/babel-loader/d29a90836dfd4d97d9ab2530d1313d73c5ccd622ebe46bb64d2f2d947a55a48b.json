{"ast":null,"code":"/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { d as doc } from './index9.js';\nimport { MENU_BACK_BUTTON_PRIORITY } from './hardware-back-button.js';\nimport { p as printIonWarning } from './index4.js';\nimport { c as componentOnReady } from './helpers.js';\nimport { b as getIonMode } from './ionic-global.js';\nimport { c as createAnimation } from './animation.js';\n\n/**\n * baseAnimation\n * Base class which is extended by the various types. Each\n * type will provide their own animations for open and close\n * and registers itself with Menu.\n */\nconst baseAnimation = isIos => {\n  // https://material.io/guidelines/motion/movement.html#movement-movement-in-out-of-screen-bounds\n  // https://material.io/guidelines/motion/duration-easing.html#duration-easing-natural-easing-curves\n  /**\n   * \"Apply the sharp curve to items temporarily leaving the screen that may return\n   * from the same exit point. When they return, use the deceleration curve. On mobile,\n   * this transition typically occurs over 300ms\" -- MD Motion Guide\n   */\n  return createAnimation().duration(isIos ? 400 : 300);\n};\n\n/**\n * Menu Overlay Type\n * The menu slides over the content. The content\n * itself, which is under the menu, does not move.\n */\nconst menuOverlayAnimation = menu => {\n  let closedX;\n  let openedX;\n  const width = menu.width + 8;\n  const menuAnimation = createAnimation();\n  const backdropAnimation = createAnimation();\n  if (menu.isEndSide) {\n    // right side\n    closedX = width + 'px';\n    openedX = '0px';\n  } else {\n    // left side\n    closedX = -width + 'px';\n    openedX = '0px';\n  }\n  menuAnimation.addElement(menu.menuInnerEl).fromTo('transform', \"translateX(\".concat(closedX, \")\"), \"translateX(\".concat(openedX, \")\"));\n  const mode = getIonMode(menu);\n  const isIos = mode === 'ios';\n  const opacity = isIos ? 0.2 : 0.25;\n  backdropAnimation.addElement(menu.backdropEl).fromTo('opacity', 0.01, opacity);\n  return baseAnimation(isIos).addAnimation([menuAnimation, backdropAnimation]);\n};\n\n/**\n * Menu Push Type\n * The content slides over to reveal the menu underneath.\n * The menu itself also slides over to reveal its bad self.\n */\nconst menuPushAnimation = menu => {\n  let contentOpenedX;\n  let menuClosedX;\n  const mode = getIonMode(menu);\n  const width = menu.width;\n  if (menu.isEndSide) {\n    contentOpenedX = -width + 'px';\n    menuClosedX = width + 'px';\n  } else {\n    contentOpenedX = width + 'px';\n    menuClosedX = -width + 'px';\n  }\n  const menuAnimation = createAnimation().addElement(menu.menuInnerEl).fromTo('transform', \"translateX(\".concat(menuClosedX, \")\"), 'translateX(0px)');\n  const contentAnimation = createAnimation().addElement(menu.contentEl).fromTo('transform', 'translateX(0px)', \"translateX(\".concat(contentOpenedX, \")\"));\n  const backdropAnimation = createAnimation().addElement(menu.backdropEl).fromTo('opacity', 0.01, 0.32);\n  return baseAnimation(mode === 'ios').addAnimation([menuAnimation, contentAnimation, backdropAnimation]);\n};\n\n/**\n * Menu Reveal Type\n * The content slides over to reveal the menu underneath.\n * The menu itself, which is under the content, does not move.\n */\nconst menuRevealAnimation = menu => {\n  const mode = getIonMode(menu);\n  const openedX = menu.width * (menu.isEndSide ? -1 : 1) + 'px';\n  const contentOpen = createAnimation().addElement(menu.contentEl) // REVIEW\n  .fromTo('transform', 'translateX(0px)', \"translateX(\".concat(openedX, \")\"));\n  return baseAnimation(mode === 'ios').addAnimation(contentOpen);\n};\nconst createMenuController = () => {\n  const menuAnimations = new Map();\n  const menus = [];\n  const open = async menu => {\n    const menuEl = await get(menu, true);\n    if (menuEl) {\n      return menuEl.open();\n    }\n    return false;\n  };\n  const close = async menu => {\n    const menuEl = await (menu !== undefined ? get(menu, true) : getOpen());\n    if (menuEl !== undefined) {\n      return menuEl.close();\n    }\n    return false;\n  };\n  const toggle = async menu => {\n    const menuEl = await get(menu, true);\n    if (menuEl) {\n      return menuEl.toggle();\n    }\n    return false;\n  };\n  const enable = async (shouldEnable, menu) => {\n    const menuEl = await get(menu);\n    if (menuEl) {\n      menuEl.disabled = !shouldEnable;\n    }\n    return menuEl;\n  };\n  const swipeGesture = async (shouldEnable, menu) => {\n    const menuEl = await get(menu);\n    if (menuEl) {\n      menuEl.swipeGesture = shouldEnable;\n    }\n    return menuEl;\n  };\n  const isOpen = async menu => {\n    if (menu != null) {\n      const menuEl = await get(menu);\n      // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n      return menuEl !== undefined && menuEl.isOpen();\n    } else {\n      const menuEl = await getOpen();\n      return menuEl !== undefined;\n    }\n  };\n  const isEnabled = async menu => {\n    const menuEl = await get(menu);\n    if (menuEl) {\n      return !menuEl.disabled;\n    }\n    return false;\n  };\n  /**\n   * Finds and returns the menu specified by \"menu\" if registered.\n   * @param menu - The side or ID of the desired menu\n   * @param logOnMultipleSideMenus - If true, this function will log a warning\n   * if \"menu\" is a side but multiple menus on the same side were found. Since this function\n   * is used in multiple places, we default this log to false so that the calling\n   * functions can choose whether or not it is appropriate to log this warning.\n   */\n  const get = async function (menu) {\n    let logOnMultipleSideMenus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    await waitUntilReady();\n    if (menu === 'start' || menu === 'end') {\n      // there could be more than one menu on the same side\n      // so first try to get the enabled one\n      const menuRefs = menus.filter(m => m.side === menu && !m.disabled);\n      if (menuRefs.length >= 1) {\n        if (menuRefs.length > 1 && logOnMultipleSideMenus) {\n          printIonWarning(\"menuController queried for a menu on the \\\"\".concat(menu, \"\\\" side, but \").concat(menuRefs.length, \" menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.\"), menuRefs.map(m => m.el));\n        }\n        return menuRefs[0].el;\n      }\n      // didn't find a menu side that is enabled\n      // so try to get the first menu side found\n      const sideMenuRefs = menus.filter(m => m.side === menu);\n      if (sideMenuRefs.length >= 1) {\n        if (sideMenuRefs.length > 1 && logOnMultipleSideMenus) {\n          printIonWarning(\"menuController queried for a menu on the \\\"\".concat(menu, \"\\\" side, but \").concat(sideMenuRefs.length, \" menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.\"), sideMenuRefs.map(m => m.el));\n        }\n        return sideMenuRefs[0].el;\n      }\n    } else if (menu != null) {\n      // the menuId was not left or right\n      // so try to get the menu by its \"id\"\n      return find(m => m.menuId === menu);\n    }\n    // return the first enabled menu\n    const menuEl = find(m => !m.disabled);\n    if (menuEl) {\n      return menuEl;\n    }\n    // get the first menu in the array, if one exists\n    return menus.length > 0 ? menus[0].el : undefined;\n  };\n  /**\n   * Get the instance of the opened menu. Returns `null` if a menu is not found.\n   */\n  const getOpen = async () => {\n    await waitUntilReady();\n    return _getOpenSync();\n  };\n  /**\n   * Get all menu instances.\n   */\n  const getMenus = async () => {\n    await waitUntilReady();\n    return getMenusSync();\n  };\n  /**\n   * Get whether or not a menu is animating. Returns `true` if any\n   * menu is currently animating.\n   */\n  const isAnimating = async () => {\n    await waitUntilReady();\n    return isAnimatingSync();\n  };\n  const registerAnimation = (name, animation) => {\n    menuAnimations.set(name, animation);\n  };\n  const _register = menu => {\n    if (menus.indexOf(menu) < 0) {\n      menus.push(menu);\n    }\n  };\n  const _unregister = menu => {\n    const index = menus.indexOf(menu);\n    if (index > -1) {\n      menus.splice(index, 1);\n    }\n  };\n  const _setOpen = async (menu, shouldOpen, animated, role) => {\n    if (isAnimatingSync()) {\n      return false;\n    }\n    if (shouldOpen) {\n      const openedMenu = await getOpen();\n      if (openedMenu && menu.el !== openedMenu) {\n        await openedMenu.setOpen(false, false);\n      }\n    }\n    return menu._setOpen(shouldOpen, animated, role);\n  };\n  const _createAnimation = (type, menuCmp) => {\n    const animationBuilder = menuAnimations.get(type); // TODO(FW-2832): type\n    if (!animationBuilder) {\n      throw new Error('animation not registered');\n    }\n    const animation = animationBuilder(menuCmp);\n    return animation;\n  };\n  const _getOpenSync = () => {\n    return find(m => m._isOpen);\n  };\n  const getMenusSync = () => {\n    return menus.map(menu => menu.el);\n  };\n  const isAnimatingSync = () => {\n    return menus.some(menu => menu.isAnimating);\n  };\n  const find = predicate => {\n    const instance = menus.find(predicate);\n    if (instance !== undefined) {\n      return instance.el;\n    }\n    return undefined;\n  };\n  const waitUntilReady = () => {\n    return Promise.all(Array.from(document.querySelectorAll('ion-menu')).map(menu => new Promise(resolve => componentOnReady(menu, resolve))));\n  };\n  registerAnimation('reveal', menuRevealAnimation);\n  registerAnimation('push', menuPushAnimation);\n  registerAnimation('overlay', menuOverlayAnimation);\n  doc === null || doc === void 0 ? void 0 : doc.addEventListener('ionBackButton', ev => {\n    const openMenu = _getOpenSync();\n    if (openMenu) {\n      ev.detail.register(MENU_BACK_BUTTON_PRIORITY, () => {\n        return openMenu.close();\n      });\n    }\n  });\n  return {\n    registerAnimation,\n    get,\n    getMenus,\n    getOpen,\n    isEnabled,\n    swipeGesture,\n    isAnimating,\n    isOpen,\n    enable,\n    toggle,\n    close,\n    open,\n    _getOpenSync,\n    _createAnimation,\n    _register,\n    _unregister,\n    _setOpen\n  };\n};\nconst menuController = /*@__PURE__*/createMenuController();\nexport { menuController as m };","map":{"version":3,"names":["d","doc","MENU_BACK_BUTTON_PRIORITY","p","printIonWarning","c","componentOnReady","b","getIonMode","createAnimation","baseAnimation","isIos","duration","menuOverlayAnimation","menu","closedX","openedX","width","menuAnimation","backdropAnimation","isEndSide","addElement","menuInnerEl","fromTo","concat","mode","opacity","backdropEl","addAnimation","menuPushAnimation","contentOpenedX","menuClosedX","contentAnimation","contentEl","menuRevealAnimation","contentOpen","createMenuController","menuAnimations","Map","menus","open","menuEl","get","close","undefined","getOpen","toggle","enable","shouldEnable","disabled","swipeGesture","isOpen","isEnabled","logOnMultipleSideMenus","arguments","length","waitUntilReady","menuRefs","filter","m","side","map","el","sideMenuRefs","find","menuId","_getOpenSync","getMenus","getMenusSync","isAnimating","isAnimatingSync","registerAnimation","name","animation","set","_register","indexOf","push","_unregister","index","splice","_setOpen","shouldOpen","animated","role","openedMenu","setOpen","_createAnimation","type","menuCmp","animationBuilder","Error","_isOpen","some","predicate","instance","Promise","all","Array","from","document","querySelectorAll","resolve","addEventListener","ev","openMenu","detail","register","menuController"],"sources":["/home/ubuntu/yanbao-miniprogram/node_modules/@ionic/core/components/index5.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { d as doc } from './index9.js';\nimport { MENU_BACK_BUTTON_PRIORITY } from './hardware-back-button.js';\nimport { p as printIonWarning } from './index4.js';\nimport { c as componentOnReady } from './helpers.js';\nimport { b as getIonMode } from './ionic-global.js';\nimport { c as createAnimation } from './animation.js';\n\n/**\n * baseAnimation\n * Base class which is extended by the various types. Each\n * type will provide their own animations for open and close\n * and registers itself with Menu.\n */\nconst baseAnimation = (isIos) => {\n    // https://material.io/guidelines/motion/movement.html#movement-movement-in-out-of-screen-bounds\n    // https://material.io/guidelines/motion/duration-easing.html#duration-easing-natural-easing-curves\n    /**\n     * \"Apply the sharp curve to items temporarily leaving the screen that may return\n     * from the same exit point. When they return, use the deceleration curve. On mobile,\n     * this transition typically occurs over 300ms\" -- MD Motion Guide\n     */\n    return createAnimation().duration(isIos ? 400 : 300);\n};\n\n/**\n * Menu Overlay Type\n * The menu slides over the content. The content\n * itself, which is under the menu, does not move.\n */\nconst menuOverlayAnimation = (menu) => {\n    let closedX;\n    let openedX;\n    const width = menu.width + 8;\n    const menuAnimation = createAnimation();\n    const backdropAnimation = createAnimation();\n    if (menu.isEndSide) {\n        // right side\n        closedX = width + 'px';\n        openedX = '0px';\n    }\n    else {\n        // left side\n        closedX = -width + 'px';\n        openedX = '0px';\n    }\n    menuAnimation.addElement(menu.menuInnerEl).fromTo('transform', `translateX(${closedX})`, `translateX(${openedX})`);\n    const mode = getIonMode(menu);\n    const isIos = mode === 'ios';\n    const opacity = isIos ? 0.2 : 0.25;\n    backdropAnimation.addElement(menu.backdropEl).fromTo('opacity', 0.01, opacity);\n    return baseAnimation(isIos).addAnimation([menuAnimation, backdropAnimation]);\n};\n\n/**\n * Menu Push Type\n * The content slides over to reveal the menu underneath.\n * The menu itself also slides over to reveal its bad self.\n */\nconst menuPushAnimation = (menu) => {\n    let contentOpenedX;\n    let menuClosedX;\n    const mode = getIonMode(menu);\n    const width = menu.width;\n    if (menu.isEndSide) {\n        contentOpenedX = -width + 'px';\n        menuClosedX = width + 'px';\n    }\n    else {\n        contentOpenedX = width + 'px';\n        menuClosedX = -width + 'px';\n    }\n    const menuAnimation = createAnimation()\n        .addElement(menu.menuInnerEl)\n        .fromTo('transform', `translateX(${menuClosedX})`, 'translateX(0px)');\n    const contentAnimation = createAnimation()\n        .addElement(menu.contentEl)\n        .fromTo('transform', 'translateX(0px)', `translateX(${contentOpenedX})`);\n    const backdropAnimation = createAnimation().addElement(menu.backdropEl).fromTo('opacity', 0.01, 0.32);\n    return baseAnimation(mode === 'ios').addAnimation([menuAnimation, contentAnimation, backdropAnimation]);\n};\n\n/**\n * Menu Reveal Type\n * The content slides over to reveal the menu underneath.\n * The menu itself, which is under the content, does not move.\n */\nconst menuRevealAnimation = (menu) => {\n    const mode = getIonMode(menu);\n    const openedX = menu.width * (menu.isEndSide ? -1 : 1) + 'px';\n    const contentOpen = createAnimation()\n        .addElement(menu.contentEl) // REVIEW\n        .fromTo('transform', 'translateX(0px)', `translateX(${openedX})`);\n    return baseAnimation(mode === 'ios').addAnimation(contentOpen);\n};\n\nconst createMenuController = () => {\n    const menuAnimations = new Map();\n    const menus = [];\n    const open = async (menu) => {\n        const menuEl = await get(menu, true);\n        if (menuEl) {\n            return menuEl.open();\n        }\n        return false;\n    };\n    const close = async (menu) => {\n        const menuEl = await (menu !== undefined ? get(menu, true) : getOpen());\n        if (menuEl !== undefined) {\n            return menuEl.close();\n        }\n        return false;\n    };\n    const toggle = async (menu) => {\n        const menuEl = await get(menu, true);\n        if (menuEl) {\n            return menuEl.toggle();\n        }\n        return false;\n    };\n    const enable = async (shouldEnable, menu) => {\n        const menuEl = await get(menu);\n        if (menuEl) {\n            menuEl.disabled = !shouldEnable;\n        }\n        return menuEl;\n    };\n    const swipeGesture = async (shouldEnable, menu) => {\n        const menuEl = await get(menu);\n        if (menuEl) {\n            menuEl.swipeGesture = shouldEnable;\n        }\n        return menuEl;\n    };\n    const isOpen = async (menu) => {\n        if (menu != null) {\n            const menuEl = await get(menu);\n            // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n            return menuEl !== undefined && menuEl.isOpen();\n        }\n        else {\n            const menuEl = await getOpen();\n            return menuEl !== undefined;\n        }\n    };\n    const isEnabled = async (menu) => {\n        const menuEl = await get(menu);\n        if (menuEl) {\n            return !menuEl.disabled;\n        }\n        return false;\n    };\n    /**\n     * Finds and returns the menu specified by \"menu\" if registered.\n     * @param menu - The side or ID of the desired menu\n     * @param logOnMultipleSideMenus - If true, this function will log a warning\n     * if \"menu\" is a side but multiple menus on the same side were found. Since this function\n     * is used in multiple places, we default this log to false so that the calling\n     * functions can choose whether or not it is appropriate to log this warning.\n     */\n    const get = async (menu, logOnMultipleSideMenus = false) => {\n        await waitUntilReady();\n        if (menu === 'start' || menu === 'end') {\n            // there could be more than one menu on the same side\n            // so first try to get the enabled one\n            const menuRefs = menus.filter((m) => m.side === menu && !m.disabled);\n            if (menuRefs.length >= 1) {\n                if (menuRefs.length > 1 && logOnMultipleSideMenus) {\n                    printIonWarning(`menuController queried for a menu on the \"${menu}\" side, but ${menuRefs.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`, menuRefs.map((m) => m.el));\n                }\n                return menuRefs[0].el;\n            }\n            // didn't find a menu side that is enabled\n            // so try to get the first menu side found\n            const sideMenuRefs = menus.filter((m) => m.side === menu);\n            if (sideMenuRefs.length >= 1) {\n                if (sideMenuRefs.length > 1 && logOnMultipleSideMenus) {\n                    printIonWarning(`menuController queried for a menu on the \"${menu}\" side, but ${sideMenuRefs.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`, sideMenuRefs.map((m) => m.el));\n                }\n                return sideMenuRefs[0].el;\n            }\n        }\n        else if (menu != null) {\n            // the menuId was not left or right\n            // so try to get the menu by its \"id\"\n            return find((m) => m.menuId === menu);\n        }\n        // return the first enabled menu\n        const menuEl = find((m) => !m.disabled);\n        if (menuEl) {\n            return menuEl;\n        }\n        // get the first menu in the array, if one exists\n        return menus.length > 0 ? menus[0].el : undefined;\n    };\n    /**\n     * Get the instance of the opened menu. Returns `null` if a menu is not found.\n     */\n    const getOpen = async () => {\n        await waitUntilReady();\n        return _getOpenSync();\n    };\n    /**\n     * Get all menu instances.\n     */\n    const getMenus = async () => {\n        await waitUntilReady();\n        return getMenusSync();\n    };\n    /**\n     * Get whether or not a menu is animating. Returns `true` if any\n     * menu is currently animating.\n     */\n    const isAnimating = async () => {\n        await waitUntilReady();\n        return isAnimatingSync();\n    };\n    const registerAnimation = (name, animation) => {\n        menuAnimations.set(name, animation);\n    };\n    const _register = (menu) => {\n        if (menus.indexOf(menu) < 0) {\n            menus.push(menu);\n        }\n    };\n    const _unregister = (menu) => {\n        const index = menus.indexOf(menu);\n        if (index > -1) {\n            menus.splice(index, 1);\n        }\n    };\n    const _setOpen = async (menu, shouldOpen, animated, role) => {\n        if (isAnimatingSync()) {\n            return false;\n        }\n        if (shouldOpen) {\n            const openedMenu = await getOpen();\n            if (openedMenu && menu.el !== openedMenu) {\n                await openedMenu.setOpen(false, false);\n            }\n        }\n        return menu._setOpen(shouldOpen, animated, role);\n    };\n    const _createAnimation = (type, menuCmp) => {\n        const animationBuilder = menuAnimations.get(type); // TODO(FW-2832): type\n        if (!animationBuilder) {\n            throw new Error('animation not registered');\n        }\n        const animation = animationBuilder(menuCmp);\n        return animation;\n    };\n    const _getOpenSync = () => {\n        return find((m) => m._isOpen);\n    };\n    const getMenusSync = () => {\n        return menus.map((menu) => menu.el);\n    };\n    const isAnimatingSync = () => {\n        return menus.some((menu) => menu.isAnimating);\n    };\n    const find = (predicate) => {\n        const instance = menus.find(predicate);\n        if (instance !== undefined) {\n            return instance.el;\n        }\n        return undefined;\n    };\n    const waitUntilReady = () => {\n        return Promise.all(Array.from(document.querySelectorAll('ion-menu')).map((menu) => new Promise((resolve) => componentOnReady(menu, resolve))));\n    };\n    registerAnimation('reveal', menuRevealAnimation);\n    registerAnimation('push', menuPushAnimation);\n    registerAnimation('overlay', menuOverlayAnimation);\n    doc === null || doc === void 0 ? void 0 : doc.addEventListener('ionBackButton', (ev) => {\n        const openMenu = _getOpenSync();\n        if (openMenu) {\n            ev.detail.register(MENU_BACK_BUTTON_PRIORITY, () => {\n                return openMenu.close();\n            });\n        }\n    });\n    return {\n        registerAnimation,\n        get,\n        getMenus,\n        getOpen,\n        isEnabled,\n        swipeGesture,\n        isAnimating,\n        isOpen,\n        enable,\n        toggle,\n        close,\n        open,\n        _getOpenSync,\n        _createAnimation,\n        _register,\n        _unregister,\n        _setOpen,\n    };\n};\nconst menuController = /*@__PURE__*/ createMenuController();\n\nexport { menuController as m };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}